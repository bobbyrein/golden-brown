{"ast":null,"code":"var util = require('util'),\n  fs = require('fs'),\n  BinaryParser = require('./binary_parser').BinaryParser,\n  Zlib = require('../zlib/zlib').Zlib,\n  RawObject = require('./raw_object').RawObject,\n  crypto = require('crypto'),\n  zlib = require('zlib');\nvar OBJ_TYPES = [null, \"commit\", \"tree\", \"blob\", \"tag\"];\nLooseStorage = exports.LooseStorage = function (directory) {\n  var _directory = directory;\n  Object.defineProperty(this, \"directory\", {\n    get: function () {\n      return _directory;\n    },\n    set: function (value) {\n      _directory = value;\n    },\n    enumerable: true\n  });\n};\nLooseStorage.prototype.find = function (sha1) {\n  try {\n    sha1 = to_hex_string(sha1);\n    // If we don't have a valid sha\n    if (sha1.length != 40) return null;\n    // Directory path\n    var path = this.directory + \"/\" + sha1.substring(0, 2) + '/' + sha1.substring(2, 40);\n    return this.get_raw_object(fs.readFileSync(path));\n  } catch (err) {\n    return null;\n  }\n};\n\n// Read and parse the raw object\nLooseStorage.prototype.get_raw_object = function (buf) {\n  if (buf.length < 2) throw \"object file too small\";\n\n  // Set up variables\n  var type = null;\n  var size = null;\n  var used = null;\n  var content = null;\n  if (this.is_legacy_loose_object(buf)) {\n    content = new Zlib.Unzip(buf).unzip();\n    content = Array.isArray(content) ? content[0] : content;\n    // Let's split the content up\n    var parts = content.split(/\\0/);\n    var header = parts.shift();\n    content = parts.join(\"\\0\");\n\n    // if no header or content we got an invalid object header\n    if (header == null || content == null) throw \"invalid object header\";\n\n    // Split out the header\n    parts = header.split(/ /);\n    type = parts[0];\n    size = parts[1];\n    // Check that we have a valid type\n    if (['blob', 'tree', 'commit', 'tag'].indexOf(type) == -1 || !size.match(/^\\d+$/)) throw \"invalid object header\";\n    // Convert parts\n    size = parseInt(size, 10);\n  } else {\n    var parts = this.unpack_object_header_gently(buf);\n    type = parts[0];\n    size = parts[1];\n    used = parts[2];\n    // Unpack content\n    content = new Zlib.Unzip(buf.slice(used, buf.length)).unzip();\n    content = Array.isArray(content) ? content[0] : content;\n  }\n  // Return a raw object\n  return new RawObject(type, content);\n};\nLooseStorage.prototype.unpack_object_header_gently = function (buf) {\n  var used = 0;\n  var c = buf[used];\n  used = used + 1;\n  var type = c >> 4 & 7;\n  var size = c & 15;\n  var shift = 4;\n  while (c & 0x80 != 0) {\n    if (buf.length <= used) throw \"object file too short\";\n    // Get next char\n    c = buf[used];\n    used = used + 1;\n    // Calculate size\n    size = size + ((c & 0x7f) << shift);\n  }\n\n  // Fetch the type\n  type = OBJ_TYPES[type];\n  // Check that we have a valid type\n  if (['blob', 'tree', 'commit', 'tag'].indexOf(type) == -1) throw \"invalid loose object type\";\n  return [type, size, used];\n};\nLooseStorage.prototype.is_legacy_loose_object = function (buf) {\n  var word = (buf[0] << 8) + buf[1];\n  return buf[0] == 0x78 && word % 31 == 0;\n};\nvar to_hex_string = function (string) {\n  var hexString = '';\n  for (var index = 0; index < string.length; index++) {\n    var value = BinaryParser.toByte(string.substr(index, 1));\n    var number = value <= 15 ? \"0\" + value.toString(16) : value.toString(16);\n    hexString = hexString + number;\n  }\n  return hexString;\n};\n\n// currently, I'm using the legacy format because it's easier to do\n// this function takes content and a type and writes out the loose object and returns a sha\nLooseStorage.prototype.put_raw_object = function (content, type, callback) {\n  var self = this;\n  // Retrieve size of message\n  var size = content.length.toString();\n  // Verify that header is ok\n  LooseStorage.verify_header(type, size);\n  // Create header\n  var header = \"\" + type + \" \" + size + \"\\0\";\n  var store = header + content;\n  // Use node crypto library to create sha1 hash\n  var hash = crypto.createHash(\"sha1\");\n  hash.update(store);\n  // Return the hash digest\n  var sha1 = hash.digest('hex');\n  // Create path\n  var path = this.directory + \"/\" + sha1.substr(0, 2) + '/' + sha1.substr(2);\n  try {\n    fs.statSync(path);\n  } catch (err) {\n    // Deflate the data\n    var data = zlib.gunzip(store, function (err, buffer) {\n      if (err) {\n        throw err;\n      }\n\n      // File does not exist create the directory\n      fs.mkdir(self.directory + \"/\" + sha1.substr(0, 2), 16877, function (err) {\n        if (err) {\n          throw err;\n        }\n        fs.writeFile(path, data, 'binary', function (err) {\n          if (err) {\n            throw err;\n          }\n          callback(sha1);\n        });\n      });\n    });\n  }\n};\nLooseStorage.verify_header = function (type, size) {\n  if ([\"blob\", \"tree\", \"commit\", \"tag\"].indexOf(type) == -1 || size.match(/^\\d+$/) == null) {\n    throw \"invalid object header\";\n  }\n};","map":{"version":3,"names":["util","require","fs","BinaryParser","Zlib","RawObject","crypto","zlib","OBJ_TYPES","LooseStorage","exports","directory","_directory","Object","defineProperty","get","set","value","enumerable","prototype","find","sha1","to_hex_string","length","path","substring","get_raw_object","readFileSync","err","buf","type","size","used","content","is_legacy_loose_object","Unzip","unzip","Array","isArray","parts","split","header","shift","join","indexOf","match","parseInt","unpack_object_header_gently","slice","c","word","string","hexString","index","toByte","substr","number","toString","put_raw_object","callback","self","verify_header","store","hash","createHash","update","digest","statSync","data","gunzip","buffer","mkdir","writeFile"],"sources":["/Users/bobbyrein/react-course/golden-brown/node_modules/git/lib/git/loose_storage.js"],"sourcesContent":["var util = require('util'),\n  fs = require('fs'),\n  BinaryParser = require('./binary_parser').BinaryParser,\n  Zlib = require('../zlib/zlib').Zlib,\n  RawObject = require('./raw_object').RawObject,\n  crypto = require('crypto'),\n  zlib = require('zlib');\n\nvar OBJ_TYPES = [null, \"commit\", \"tree\", \"blob\", \"tag\"];\n\nLooseStorage = exports.LooseStorage = function(directory) {\n  var _directory = directory;\n\n  Object.defineProperty(this, \"directory\", { get: function() { return _directory; }, set: function(value) { _directory = value; }, enumerable: true});    \n}\n\nLooseStorage.prototype.find = function(sha1) {\n  try {\n    sha1 = to_hex_string(sha1);\n    // If we don't have a valid sha\n    if(sha1.length != 40) return null;\n    // Directory path\n    var path = this.directory + \"/\" + sha1.substring(0, 2) + '/' + sha1.substring(2, 40);\n    return this.get_raw_object(fs.readFileSync(path));    \n  } catch(err) {\n    return null;\n  }\n}\n\n// Read and parse the raw object\nLooseStorage.prototype.get_raw_object = function(buf) {\n  if(buf.length < 2) throw \"object file too small\";\n\n  // Set up variables\n  var type = null;\n  var size = null;\n  var used = null;\n  var content = null;\n\n  if(this.is_legacy_loose_object(buf)) {\n    content = new Zlib.Unzip(buf).unzip();\n    content = Array.isArray(content) ? content[0] : content;\n    // Let's split the content up\n    var parts = content.split(/\\0/)\n    var header = parts.shift();\n    content = parts.join(\"\\0\");\n    \n    // if no header or content we got an invalid object header\n    if(header == null || content == null) throw \"invalid object header\";\n    \n    // Split out the header\n    parts = header.split(/ /);\n    type = parts[0];\n    size = parts[1];\n    // Check that we have a valid type\n    if(['blob', 'tree', 'commit', 'tag'].indexOf(type) == -1 || !size.match(/^\\d+$/)) throw \"invalid object header\";\n    // Convert parts\n    size = parseInt(size, 10);    \n  } else {\n    var parts = this.unpack_object_header_gently(buf);\n    type = parts[0];\n    size = parts[1];\n    used = parts[2];\n    // Unpack content\n    content = new Zlib.Unzip(buf.slice(used, buf.length)).unzip();\n    content = Array.isArray(content) ? content[0] : content;\n  }\n  // Return a raw object\n  return new RawObject(type, content);\n}\n\nLooseStorage.prototype.unpack_object_header_gently = function(buf) {\n  var used = 0\n  var c = buf[used];\n  used = used + 1;\n  \n  var type = (c >> 4) & 7;\n  var size = c & 15;\n  var shift = 4;\n  \n  while(c & 0x80 != 0) {\n    if(buf.length <= used) throw \"object file too short\";\n    // Get next char\n    c = buf[used];\n    used = used + 1;\n    // Calculate size\n    size = size + ((c & 0x7f) << shift);    \n  }\n  \n  // Fetch the type\n  type = OBJ_TYPES[type];\n  // Check that we have a valid type\n  if(['blob', 'tree', 'commit', 'tag'].indexOf(type) == -1) throw \"invalid loose object type\";\n  return [type, size, used];\n}\n\nLooseStorage.prototype.is_legacy_loose_object = function(buf) {\n  var word = (buf[0] << 8) + buf[1];\n  return buf[0] == 0x78 && word % 31 == 0;\n}\n\nvar to_hex_string = function(string) {\n  var hexString = '';\n  for(var index = 0; index < string.length; index++) {\n    var value = BinaryParser.toByte(string.substr(index, 1));\n    var number = value <= 15 ? \"0\" + value.toString(16) : value.toString(16);\n    hexString = hexString + number;\n  }\n  return hexString;\n};\n\n// currently, I'm using the legacy format because it's easier to do\n// this function takes content and a type and writes out the loose object and returns a sha\nLooseStorage.prototype.put_raw_object = function(content, type, callback) {\n  var self = this;\n  // Retrieve size of message\n  var size = content.length.toString();    \n  // Verify that header is ok\n  LooseStorage.verify_header(type, size);  \n  // Create header\n  var header = \"\" + type + \" \" + size + \"\\0\";\n  var store = header + content;  \n  // Use node crypto library to create sha1 hash\n  var hash = crypto.createHash(\"sha1\");\n  hash.update(store);\n  // Return the hash digest\n  var sha1 = hash.digest('hex');\n  // Create path\n  var path = this.directory +  \"/\" + sha1.substr(0, 2) + '/' + sha1.substr(2);\n  \n  try {\n    fs.statSync(path);\n  } catch(err) {    \n    // Deflate the data\n    var data = zlib.gunzip(store, function (err, buffer) {\n      if (err) {\n        throw err;\n      }\n\n      // File does not exist create the directory\n      fs.mkdir(self.directory + \"/\" + sha1.substr(0, 2), 16877, function (err) {\n        if (err) {\n          throw err;\n        }\n\n        fs.writeFile(path, data, 'binary', function (err) {\n          if (err) {\n            throw err;\n          }\n\n          callback(sha1);\n        });\n      });\n    });\n  }\n}\n\nLooseStorage.verify_header = function(type, size) {\n  if([\"blob\", \"tree\", \"commit\", \"tag\"].indexOf(type) == -1 || size.match(/^\\d+$/) == null) {\n    throw \"invalid object header\";\n  }\n}\n\n\n\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}