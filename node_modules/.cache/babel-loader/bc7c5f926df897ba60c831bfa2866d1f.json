{"ast":null,"code":"var util = require('util'),\n  fs = require('fs'),\n  exec = require('child_process').exec;\nvar GitFileOperations = exports.GitFileOperations = function () {};\n\n// Streaming glob function\nvar streaming_glob_function = function (path, stream) {\n  var entries = fs.readdirSync(path);\n  entries.forEach(function (entry) {\n    var entry_path = path + \"/\" + entry;\n    var stat = fs.statSync(entry_path);\n    if (stat.isDirectory()) {\n      stream.emit(\"data\", {\n        path: entry_path,\n        stat: stat\n      });\n      streaming_glob_function(entry_path, stream);\n    } else {\n      stream.emit(\"data\", {\n        path: entry_path,\n        stat: stat\n      });\n    }\n  });\n};\nvar stat_with_entry = function (entry_path, stream, callback) {\n  return function () {\n    fs.stat(entry_path, function (err, stat) {\n      if (stat.isDirectory()) {\n        // Dive into the directory\n        streaming_glob_function(entry_path, stream);\n        // Emit the directory and then update the count\n        stream.emit(\"data\", {\n          path: entry_path,\n          stat: stat\n        });\n        callback();\n      } else if (stat.isFile()) {\n        // Update the number of processed directories and emit the data event\n        stream.emit(\"data\", {\n          path: entry_path,\n          stat: stat\n        });\n        callback();\n      }\n    });\n  };\n};\n\n// Glob function for the file system\nGitFileOperations.glob_streaming = function (path) {\n  // Comptability\n  var nextTick = global.setImmediate || process.nextTick;\n  // Create a stream object\n  var stream = new process.EventEmitter();\n  var processed_directories_count = 0;\n  var top_level_files_count = -1;\n  // Tick method\n  var tick_function = function () {\n    // If we are done emit end otherwise execute the method again\n    processed_directories_count == top_level_files_count ? stream.emit(\"end\") : nextTick(tick_function);\n  };\n  // set nextTick handler into action\n  nextTick(tick_function);\n  // Fetch the top directory\n  fs.readdir(path, function (err, entries) {\n    // The top level of files that need to be finished processing for us to be done\n    if (entries !== undefined && entries.length > 0) {\n      entries.sort(function (a, b) {\n        return a > b;\n      });\n      top_level_files_count = entries.length;\n      // Execute the entries\n      var procesEntry = function (i) {\n        // Entry path\n        var entry_path = path + \"/\" + entries[i];\n        // Build glob function\n        stat_with_entry(entry_path, stream, function () {\n          processed_directories_count = processed_directories_count + 1;\n          if (++i < entries.length) {\n            procesEntry(i);\n          }\n        })();\n      };\n      procesEntry(0);\n    } else {\n      top_level_files_count = 0;\n    }\n  });\n  // Return the stream for execution\n  return stream;\n};\n\n// Execute recursive glob function (private function)\nvar glob_function = function (path, files) {\n  var entries = fs.readdirSync(path);\n  entries.forEach(function (entry) {\n    var entry_path = path + \"/\" + entry;\n    var stat = fs.statSync(entry_path);\n    if (stat.isDirectory()) {\n      glob_function(entry_path, files);\n    } else {\n      files.push(entry_path);\n    }\n  });\n};\n\n// Glob function for the file system\nGitFileOperations.glob = function (path, files, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  files = args.length ? args.shift() : [];\n  // Fetch all the files\n  glob_function(path, files);\n  callback(null, files);\n};\n\n// Read a file\nGitFileOperations.fs_read = function (path, file, callback) {\n  fs.readFile(path + \"/\" + file, callback);\n};\n\n// Make a directory\nGitFileOperations.fs_mkdir = function (dir, callback) {\n  fs.mkdir(dir, 16877, callback);\n};\n\n// Check if a directory exists\nGitFileOperations.fs_exist = function (dir, path, callback) {};\n\n// Delete directory\nGitFileOperations.fs_rmdir_r = function (dir, callback) {\n  // Copy the old directory to the new one\n  var child = exec('rm -rf ' + dir, function (error, stdout, stderr) {\n    if (error !== null) {\n      util.puts('exec error: ' + error);\n      return callback(error, null);\n    }\n    return callback(null, null);\n  });\n};\n\n// Write file\nGitFileOperations.fs_write = function (dir, file, content, callback) {\n  // Let's make sure the parent directories exist, split the file into directories and content\n  var file_parts = file.split(\"/\");\n  var file_name = file_parts.pop();\n  var current_path = dir;\n  // Create missing sub directories\n  while (file_parts.length > 0) {\n    var dir_path = file_parts.shift();\n    current_path = current_path + \"/\" + dir_path;\n    // Check if the directory exists (if it does not then create it)\n    try {\n      fs.statSync(current_path);\n    } catch (err) {\n      fs.mkdirSync(current_path, 16877);\n    }\n  }\n\n  // Write the file to disk\n  current_path = dir + \"/\" + file;\n  // Append the entry to the file\n  fs.writeFile(current_path, content, callback);\n};","map":{"version":3,"names":["util","require","fs","exec","GitFileOperations","exports","streaming_glob_function","path","stream","entries","readdirSync","forEach","entry","entry_path","stat","statSync","isDirectory","emit","stat_with_entry","callback","err","isFile","glob_streaming","nextTick","global","setImmediate","process","EventEmitter","processed_directories_count","top_level_files_count","tick_function","readdir","undefined","length","sort","a","b","procesEntry","i","glob_function","files","push","glob","args","Array","prototype","slice","call","arguments","pop","shift","fs_read","file","readFile","fs_mkdir","dir","mkdir","fs_exist","fs_rmdir_r","child","error","stdout","stderr","puts","fs_write","content","file_parts","split","file_name","current_path","dir_path","mkdirSync","writeFile"],"sources":["/Users/bobbyrein/react-course/golden-brown/node_modules/git/lib/git/git_file_operations.js"],"sourcesContent":["var util = require('util'),\n  fs = require('fs'),\n  exec  = require('child_process').exec;\n\nvar GitFileOperations = exports.GitFileOperations = function() {}\n\n// Streaming glob function\nvar streaming_glob_function = function(path, stream) {\n  var entries = fs.readdirSync(path);\n  entries.forEach(function(entry) {\n    var entry_path = path + \"/\" + entry;    \n    var stat = fs.statSync(entry_path);\n    \n    if(stat.isDirectory()) {\n      stream.emit(\"data\", {path:entry_path, stat:stat});\n      streaming_glob_function(entry_path, stream);\n    } else {\n      stream.emit(\"data\", {path:entry_path, stat:stat});\n    }\n  })\n}\n\nvar stat_with_entry = function(entry_path, stream, callback) {\n  return function() {\n    fs.stat(entry_path, function(err, stat) {\n      if(stat.isDirectory()) {\n        // Dive into the directory\n        streaming_glob_function(entry_path, stream);\n        // Emit the directory and then update the count\n        stream.emit(\"data\", {path:entry_path, stat:stat});\n        callback();\n      } else if(stat.isFile()) {\n        // Update the number of processed directories and emit the data event\n        stream.emit(\"data\", {path:entry_path, stat:stat});\n        callback();\n      }\n    });    \n  }\n}\n\n// Glob function for the file system\nGitFileOperations.glob_streaming  = function(path) {\n  // Comptability\n  var nextTick = global.setImmediate || process.nextTick;\n  // Create a stream object\n  var stream = new process.EventEmitter();\n  var processed_directories_count = 0;\n  var top_level_files_count = -1;\n  // Tick method\n  var tick_function = function() {\n    // If we are done emit end otherwise execute the method again\n    processed_directories_count == top_level_files_count ? stream.emit(\"end\") : nextTick(tick_function);\n  }\n  // set nextTick handler into action\n  nextTick(tick_function);\n  // Fetch the top directory\n  fs.readdir(path, function(err, entries) {\n    // The top level of files that need to be finished processing for us to be done\n    if(entries !== undefined && entries.length > 0)  {\n      entries.sort(function(a, b) {\n          return a > b;\n      });\n\n      top_level_files_count = entries.length;\n      // Execute the entries\n      var procesEntry = function(i) {\n        // Entry path\n        var entry_path = path + \"/\" + entries[i];\n        // Build glob function\n        stat_with_entry(entry_path, stream, function() {\n          processed_directories_count = processed_directories_count + 1;\n          if (++i < entries.length) {\n            procesEntry(i);\n          }\n        })();\n      };\n      procesEntry(0);\n    } else {\n      top_level_files_count = 0;\n    }\n  });  \n  // Return the stream for execution\n  return stream;\n}\n\n// Execute recursive glob function (private function)\nvar glob_function = function(path, files) {\n  var entries = fs.readdirSync(path);\n  entries.forEach(function(entry) {\n    var entry_path = path + \"/\" + entry;\n    \n    var stat = fs.statSync(entry_path);\n    if(stat.isDirectory()) {\n      glob_function(entry_path, files);\n    } else {\n      files.push(entry_path);\n    }\n  })\n}\n\n// Glob function for the file system\nGitFileOperations.glob = function(path, files, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  files = args.length ? args.shift() : [];\n  // Fetch all the files\n  glob_function(path, files);\n  callback(null, files);\n}\n\n// Read a file\nGitFileOperations.fs_read = function(path, file, callback) {\n  fs.readFile(path + \"/\" + file, callback);\n} \n\n// Make a directory\nGitFileOperations.fs_mkdir = function(dir, callback) {\n  fs.mkdir(dir, 16877, callback);\n}\n\n// Check if a directory exists\nGitFileOperations.fs_exist = function(dir, path, callback) {\n}\n\n// Delete directory\nGitFileOperations.fs_rmdir_r = function(dir, callback) {\n  // Copy the old directory to the new one\n  var child = exec('rm -rf ' + dir, function (error, stdout, stderr) {\n      if (error !== null) {\n        util.puts('exec error: ' + error);\n        return callback(error, null);\n      }\n      return callback(null, null);    \n  });    \n}\n\n// Write file\nGitFileOperations.fs_write = function(dir, file, content, callback) {  \n  // Let's make sure the parent directories exist, split the file into directories and content\n  var file_parts = file.split(\"/\");\n  var file_name = file_parts.pop()\n  var current_path = dir;\n  // Create missing sub directories\n  while(file_parts.length > 0) {\n    var dir_path = file_parts.shift();\n    current_path = current_path + \"/\" + dir_path;\n    // Check if the directory exists (if it does not then create it)\n    try {\n      fs.statSync(current_path);      \n    } catch(err) {\n      fs.mkdirSync(current_path, 16877);\n    }\n  }\n  \n  // Write the file to disk\n  current_path = dir + \"/\" + file;\n  // Append the entry to the file\n  fs.writeFile(current_path, content, callback);\n}\n\n\n\n\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}