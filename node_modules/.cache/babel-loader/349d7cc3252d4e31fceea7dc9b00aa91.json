{"ast":null,"code":"var util = require('util'),\n  fs = require('fs'),\n  Buffer = require('buffer').Buffer,\n  BinaryParser = require('./binary_parser').BinaryParser,\n  FileWindow = require('./file_window').FileWindow,\n  RawObject = require('./raw_object').RawObject;\nZlib = require('../zlib/zlib').Zlib;\nvar PACK_IDX_SIGNATURE = '\\xfftOc';\nvar FAN_OUT_COUNT = 256;\nvar IDX_OFFSET_SIZE = 4;\nvar OFFSET_SIZE = 4;\nvar OFFSET_START = FAN_OUT_COUNT * IDX_OFFSET_SIZE;\nvar SHA1_SIZE = 20;\nvar CRC_SIZE = 4;\nvar SHA1_START = OFFSET_START + OFFSET_SIZE;\nvar ENTRY_SIZE = OFFSET_SIZE + SHA1_SIZE;\nvar ENTRY_SIZE_V2 = SHA1_SIZE + CRC_SIZE + OFFSET_SIZE;\n\n// Default types\nvar OBJ_NONE = 0;\nvar OBJ_COMMIT = 1;\nvar OBJ_TREE = 2;\nvar OBJ_BLOB = 3;\nvar OBJ_TAG = 4;\nvar OBJ_OFS_DELTA = 6;\nvar OBJ_REF_DELTA = 7;\nvar OBJ_TYPES = [null, \"commit\", \"tree\", \"blob\", \"tag\"];\nvar PackStorage = exports.PackStorage = function (file) {\n  var _name = file,\n    _cache = {},\n    _version = null,\n    _offsets = null,\n    _size = 0;\n  // Replace idx reference with pack\n  if (file.match(/\\.idx$/)) {\n    file = file.substr(0, file.length - 3) + \"pack\";\n  }\n  Object.defineProperty(this, \"name\", {\n    get: function () {\n      return _name;\n    },\n    set: function (value) {\n      _name = value;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"cache\", {\n    get: function () {\n      return _cache;\n    },\n    set: function (value) {\n      _cache = value;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"version\", {\n    get: function () {\n      return _version;\n    },\n    set: function (value) {\n      _version = value;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"offsets\", {\n    get: function () {\n      return _offsets;\n    },\n    set: function (value) {\n      _offsets = value;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"size\", {\n    get: function () {\n      return _size;\n    },\n    set: function (value) {\n      _size = value;\n    },\n    enumerable: true\n  });\n  // Initialize pack\n  init_pack(this);\n};\n\n// Search for a sha1 in the pack\nPackStorage.prototype.find = function (sha1) {\n  // If we have the object in the cache return it\n  if (this.cache[sha1]) return this.cache[sha1];\n  // We need to search for the object in the pack file\n  var offset = find_object(this, sha1);\n  // If no object found return null\n  if (!offset) return null;\n  // Parse the object at the located offset\n  var obj = this.parse_object(this, offset);\n  this.cache[sha1] = obj;\n  return obj;\n};\n\n// Close the pack (nothing should be open, might be able to remove this TODO)\nPackStorage.prototype.close = function () {};\nPackStorage.prototype.parse_object = function (pack, offset) {\n  // Open the pack file\n  var packfile = fs.openSync(pack.name, \"r\");\n  var result = this.unpack_object(pack, packfile, offset);\n  var data = result[0];\n  var type = result[1];\n  // Close the packfile\n  fs.closeSync(packfile);\n  return new RawObject(OBJ_TYPES[type], data);\n};\nPackStorage.prototype.unpack_object = function (pack, packfile, offset, options) {\n  // Ensure valid options variable\n  options = options ? options : {};\n  var obj_offset = offset;\n\n  // TODO TODO TODO TODO TODO TODO\n  // TODO TODO TODO TODO TODO TODO\n  // TODO TODO TODO TODO TODO TODO\n\n  var buf = new Buffer(1);\n  fs.readSync(packfile, buf, 0, 1, offset);\n  // Fetch the first byte\n  var c = buf[0];\n  var size = c & 0xf;\n  var type = c >> 4 & 7;\n  var shift = 4;\n  var offset = offset + 1;\n  // unpack until we have decoded size\n  while ((c & 0x80) != 0) {\n    fs.readSync(packfile, buf, 0, 1, offset);\n    c = buf[0];\n    // Adjust size for the byte\n    size = size | (c & 0x7f) << shift;\n    shift = shift + 7;\n    offset = offset + 1;\n  }\n\n  // If it's not a commit or tree and caching is enabled then return false\n  if (!(type == OBJ_COMMIT || type == OBJ_TREE) && options['caching']) return [false, false];\n  // Check the type of object and either unpack the delta or the compressed data (gziped)\n  if (type == OBJ_OFS_DELTA || type == OBJ_REF_DELTA) {\n    return this.unpack_deltified(packfile, type, offset, obj_offset, size, options);\n  } else if (type == OBJ_COMMIT || type == OBJ_TREE || type == OBJ_BLOB || type == OBJ_TAG) {\n    var data = unpack_compressed(pack, offset, size);\n    return [data, type];\n  } else {\n    throw new \"invalid type \"() + type;\n  }\n};\nPackStorage.prototype.unpack_deltified = function (packfile, type, offset, obj_offset, size, options) {\n  var data = new Buffer(SHA1_SIZE);\n  // Read the SHA\n  fs.readSync(packfile, data, 0, SHA1_SIZE, offset);\n  if (type == OBJ_OFS_DELTA) {\n    var i = 0;\n    var c = data[i];\n    var base_offset = c & 0x7f;\n    while ((c & 0x80) != 0) {\n      c = data[++i];\n      base_offset = base_offset + 1;\n      base_offset = base_offset << 7;\n      base_offset = base_offset | c & 0x7f;\n    }\n    base_offset = obj_offset - base_offset;\n    offset = offset + i + 1;\n  } else {\n    base_offset = find_object(this, data.toString());\n    offset = offset + SHA1_SIZE;\n  }\n\n  // Fetch the object at this offset and unpack the result\n  var object_array = this.unpack_object(this, packfile, base_offset);\n  var base = object_array[0];\n  var type = object_array[1];\n  // If it's not a Commit or Tree return an empty delta\n  if (!(type == OBJ_COMMIT || type == OBJ_TREE) && options['caching']) return [false, false];\n  // Unpack the the data\n  var delta = unpack_compressed(this, offset, size);\n  var delta2 = patch_delta(base, delta);\n  return [delta2, type];\n};\nvar to_hex_string = function (string) {\n  var hexString = '';\n  for (var index = 0; index < string.length; index++) {\n    var value = BinaryParser.toByte(string.substr(index, 1));\n    var number = value <= 15 ? \"0\" + value.toString(16) : value.toString(16);\n    hexString = hexString + number;\n  }\n  return hexString;\n};\nvar patch_delta = function (base, delta) {\n  var delta_header_parts = patch_delta_header_size(delta, 0);\n  var src_size = delta_header_parts[0];\n  var pos = delta_header_parts[1];\n  if (src_size != base.length) throw \"invalid delta data\";\n  delta_header_parts = patch_delta_header_size(delta, pos);\n  var dest_size = delta_header_parts[0];\n  pos = delta_header_parts[1];\n  var dest = '';\n  while (pos < delta.length) {\n    var c = delta.charCodeAt(pos);\n    pos = pos + 1;\n\n    // Keep reading until end of data pack\n    if ((c & 0x80) != 0) {\n      pos = pos - 1;\n      var cp_off = 0;\n      var cp_size = 0;\n      if ((c & 0x01) != 0) cp_off = delta.charCodeAt(pos += 1);\n      if ((c & 0x02) != 0) cp_off = cp_off | delta.charCodeAt(pos += 1) << 8;\n      if ((c & 0x04) != 0) cp_off = cp_off | delta.charCodeAt(pos += 1) << 16;\n      if ((c & 0x08) != 0) cp_off = cp_off | delta.charCodeAt(pos += 1) << 24;\n      if ((c & 0x10) != 0) cp_size = delta.charCodeAt(pos += 1);\n      if ((c & 0x20) != 0) cp_size = cp_size | delta.charCodeAt(pos += 1) << 8;\n      if ((c & 0x40) != 0) cp_size = cp_size | delta.charCodeAt(pos += 1) << 16;\n      if (cp_size == 0) cp_size = 0x10000;\n      pos = pos + 1;\n      dest = dest + base.substr(cp_off, cp_size);\n    } else if (c != 0) {\n      dest = dest + delta.substr(pos, c);\n      pos = pos + c;\n    } else {\n      throw \"invalid delta data\";\n    }\n  }\n  return dest;\n};\nvar patch_delta_header_size = function (delta, pos) {\n  var size = 0;\n  var shift = 0;\n  do {\n    var c = delta.charCodeAt(pos);\n    if (c == null) throw 'invalid delta data';\n    pos = pos + 1;\n    size = size | (c & 0x7f) << shift;\n    shift = shift + 7;\n  } while ((c & 0x80) != 0);\n\n  // Return the header size and position\n  return [size, pos];\n};\nvar unpack_compressed = function (pack, offset, destsize) {\n  var outdata = \"\";\n  var file_offset = offset;\n  var packfile = fs.openSync(pack.name, \"r\");\n\n  // Read in the compressed object (this could be huge :() \n  // TODO TODO TODO, change unzip method to allow for initializing the structure and then decoding \n  // pieces\n  var indata = new Buffer(destsize + 100);\n  var bytes_read = fs.readSync(packfile, indata, 0, destsize + 100, file_offset);\n  // Close the file\n  fs.closeSync(packfile);\n  // Adjust the file_offset\n  file_offset = file_offset + destsize;\n  outdata = outdata + new Zlib.Unzip(indata).unzip();\n  if (outdata.size > destsize) {\n    throw \"error reading pack data\";\n  }\n  // Return the data read from the compressed block\n  return outdata;\n};\nvar find_object_in_index = function (pack, idx, sha1) {\n  // Parse the first value of the sha as an index\n  var slot = sha1.charCodeAt(0);\n  if (slot == NaN) return null;\n\n  // Unpack the variables\n  var first = pack.offsets[slot];\n  var last = pack.offsets[slot + 1];\n  while (first < last) {\n    var mid = parseInt((first + last) / 2);\n    // If we have a version 2 pack file\n    if (pack.version == 2) {\n      // Fetch the sha1\n      var midsha1 = idx.index([OFFSET_START + mid * SHA1_SIZE, SHA1_SIZE]);\n      var compare_sha1 = '';\n      // Convert midsha1 to allow for correct string comparision\n      for (var i = 0; i < midsha1.length; i++) {\n        compare_sha1 = compare_sha1 + String.fromCharCode(midsha1[i]);\n      }\n\n      // Do a locale Compare\n      var cmp = compare_sha1.localeCompare(sha1);\n      if (cmp < 0) {\n        first = mid + 1;\n      } else if (cmp > 0) {\n        last = mid;\n      } else {\n        var pos = OFFSET_START + pack.size * (SHA1_SIZE + CRC_SIZE) + mid * OFFSET_SIZE;\n        var offset = idx.index([pos, OFFSET_SIZE]);\n        offset = BinaryParser.toInt(reverse_buffer(offset).toString('binary', 0, 4));\n        return offset;\n      }\n    } else {\n      var midsha1 = idx.index([SHA1_START + mid * ENTRY_SIZE, SHA1_SIZE]);\n      var compare_sha1 = '';\n      // Convert midsha1 to allow for correct string comparision\n      for (var i = 0; i < midsha1.length; i++) {\n        compare_sha1 = compare_sha1 + String.fromCharCode(midsha1[i]);\n      }\n\n      // Do a locale Compare\n      var cmp = compare_sha1.localeCompare(sha1);\n      if (cmp < 0) {\n        first = mid + 1;\n      } else if (cmp > 0) {\n        last = mid;\n      } else {\n        var pos = OFFSET_START + mid * ENTRY_SIZE;\n        var offset = idx.index([pos, OFFSET_SIZE]);\n        offset = BinaryParser.toInt(reverse_buffer(offset).toString('binary', 0, 4));\n        return offset;\n      }\n    }\n  }\n  return null;\n};\nvar find_object = function (pack, sha1) {\n  var obj = null;\n  // Should I not use the cached version in the future ? TODO\n  with_idx(pack, function (err, idx) {\n    obj = find_object_in_index(pack, idx, sha1);\n  });\n  return obj;\n};\nvar reverse_buffer = function (buffer) {\n  var result_buffer = new Buffer(buffer.length);\n  var length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    result_buffer[length - 1 - i] = buffer[i];\n  }\n  return result_buffer;\n};\nvar init_pack = function (pack) {\n  // TODO TODO TODO\n  with_idx(pack, function (err, idx) {\n    // Reset pack offsets\n    pack.offsets = [0];\n    // Do a max of FAN_OUT_COUNT to avoid going crazy\n    for (var i = 0; i < FAN_OUT_COUNT; i++) {\n      // Each offset value is a 4 byte network encoded integer\n      var pos = idx.index([i * IDX_OFFSET_SIZE, IDX_OFFSET_SIZE]);\n      pos = BinaryParser.toInt(reverse_buffer(pos).toString('binary', 0, 4));\n      // If the position is less than the pack offset stored the pack index is corrupt\n      if (pos < pack.offsets[i]) {\n        throw \"pack \" + pack.name + \" has discontinuous index \" + i;\n      }\n      // Add offset position to list of tracked offsets\n      pack.offsets.push(pos);\n    }\n    // Adjust the pack size\n    pack.size = pack.offsets[pack.offsets.length - 1];\n    // Close all files\n    idx.close();\n  });\n};\nvar with_idx = function (pack, index_file, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  index_file = args.length ? args.shift() : null;\n  // Final idx file name\n  var idx_file_name = null;\n  // Define file handle variable\n  var idxfile = null;\n  if (!index_file) {\n    index_file = pack.name;\n    idx_file_name = pack.name.substr(0, pack.name.length - 4) + \"idx\";\n    idxfile = fs.openSync(pack.name.substr(0, pack.name.length - 4) + \"idx\", \"r\");\n  } else {\n    idx_file_name = index_file;\n    idxfile = fs.openSync(index_file, \"r\");\n  }\n\n  // Read header\n  var sign_buffer = new Buffer(4);\n  var signature = '';\n  fs.readSync(idxfile, sign_buffer, 0, 4);\n  for (var i = 0; i < sign_buffer.length; i++) {\n    signature = signature + BinaryParser.fromByte(sign_buffer[i]);\n  }\n\n  // Extract version of pack\n  var ver_buffer = new Buffer(4);\n  fs.readSync(idxfile, ver_buffer, 0, 4);\n  var ver = BinaryParser.toInt(reverse_buffer(ver_buffer).toString('binary', 0, 4));\n  // Close idx file\n  fs.closeSync(idxfile);\n  // If we have a IDX pack signature this is at least version 2 of the file format\n  if (signature == PACK_IDX_SIGNATURE) {\n    if (ver != 2) {\n      throw \"pack \" + pack.name + \" has unknown pack file version \" + ver;\n    }\n    pack.version = 2;\n  } else {\n    pack.version = 1;\n  }\n  // Create a file window and return it\n  var idx = new FileWindow(idx_file_name, pack.version);\n  callback(null, idx);\n};","map":{"version":3,"names":["util","require","fs","Buffer","BinaryParser","FileWindow","RawObject","Zlib","PACK_IDX_SIGNATURE","FAN_OUT_COUNT","IDX_OFFSET_SIZE","OFFSET_SIZE","OFFSET_START","SHA1_SIZE","CRC_SIZE","SHA1_START","ENTRY_SIZE","ENTRY_SIZE_V2","OBJ_NONE","OBJ_COMMIT","OBJ_TREE","OBJ_BLOB","OBJ_TAG","OBJ_OFS_DELTA","OBJ_REF_DELTA","OBJ_TYPES","PackStorage","exports","file","_name","_cache","_version","_offsets","_size","match","substr","length","Object","defineProperty","get","set","value","enumerable","init_pack","prototype","find","sha1","cache","offset","find_object","obj","parse_object","close","pack","packfile","openSync","name","result","unpack_object","data","type","closeSync","options","obj_offset","buf","readSync","c","size","shift","unpack_deltified","unpack_compressed","i","base_offset","toString","object_array","base","delta","delta2","patch_delta","to_hex_string","string","hexString","index","toByte","number","delta_header_parts","patch_delta_header_size","src_size","pos","dest_size","dest","charCodeAt","cp_off","cp_size","destsize","outdata","file_offset","indata","bytes_read","Unzip","unzip","find_object_in_index","idx","slot","NaN","first","offsets","last","mid","parseInt","version","midsha1","compare_sha1","String","fromCharCode","cmp","localeCompare","toInt","reverse_buffer","with_idx","err","buffer","result_buffer","push","index_file","callback","args","Array","slice","call","arguments","pop","idx_file_name","idxfile","sign_buffer","signature","fromByte","ver_buffer","ver"],"sources":["/Users/bobbyrein/react-course/golden-brown/node_modules/git/lib/git/pack_storage.js"],"sourcesContent":["var util = require('util'),\n  fs = require('fs'),\n  Buffer = require('buffer').Buffer,\n  BinaryParser = require('./binary_parser').BinaryParser,\n  FileWindow = require('./file_window').FileWindow,\n  RawObject = require('./raw_object').RawObject;\n  Zlib = require('../zlib/zlib').Zlib;\n  \nvar PACK_IDX_SIGNATURE = '\\xfftOc';\nvar FAN_OUT_COUNT = 256;\nvar IDX_OFFSET_SIZE = 4;\nvar OFFSET_SIZE = 4;\nvar OFFSET_START = FAN_OUT_COUNT * IDX_OFFSET_SIZE;\nvar SHA1_SIZE = 20;\nvar CRC_SIZE = 4;\nvar SHA1_START = OFFSET_START + OFFSET_SIZE;\nvar ENTRY_SIZE = OFFSET_SIZE + SHA1_SIZE;\nvar ENTRY_SIZE_V2 = SHA1_SIZE + CRC_SIZE + OFFSET_SIZE;\n\n// Default types\nvar OBJ_NONE = 0;\nvar OBJ_COMMIT = 1;\nvar OBJ_TREE = 2;\nvar OBJ_BLOB = 3;\nvar OBJ_TAG = 4;\nvar OBJ_OFS_DELTA = 6;\nvar OBJ_REF_DELTA = 7;\nvar OBJ_TYPES = [null, \"commit\", \"tree\", \"blob\", \"tag\"];\n\nvar PackStorage = exports.PackStorage = function(file) {\n  var _name = file, _cache = {}, _version = null, _offsets = null, _size = 0;\n  // Replace idx reference with pack\n  if(file.match(/\\.idx$/)) {\n    file = file.substr(0, file.length - 3) + \"pack\";\n  }\n  \n  Object.defineProperty(this, \"name\", { get: function() { return _name; }, set: function(value) { _name = value; }, enumerable: true});        \n  Object.defineProperty(this, \"cache\", { get: function() { return _cache; }, set: function(value) { _cache = value; }, enumerable: true});        \n  Object.defineProperty(this, \"version\", { get: function() { return _version; }, set: function(value) { _version = value; }, enumerable: true});        \n  Object.defineProperty(this, \"offsets\", { get: function() { return _offsets; }, set: function(value) { _offsets = value; }, enumerable: true});        \n  Object.defineProperty(this, \"size\", { get: function() { return _size; }, set: function(value) { _size = value; }, enumerable: true});        \n  // Initialize pack\n  init_pack(this);\n}\n\n// Search for a sha1 in the pack\nPackStorage.prototype.find = function(sha1) {\n  // If we have the object in the cache return it\n  if(this.cache[sha1]) return this.cache[sha1];\n  // We need to search for the object in the pack file\n  var offset = find_object(this, sha1);  \n  // If no object found return null\n  if(!offset) return null;\n  // Parse the object at the located offset\n  var obj = this.parse_object(this, offset);\n  this.cache[sha1] = obj;\n  return obj;\n}\n\n// Close the pack (nothing should be open, might be able to remove this TODO)\nPackStorage.prototype.close = function() {  \n}\n\nPackStorage.prototype.parse_object = function(pack, offset) {  \n  // Open the pack file\n  var packfile = fs.openSync(pack.name, \"r\");\n  var result = this.unpack_object(pack, packfile, offset);\n  var data = result[0];\n  var type = result[1];\n  // Close the packfile\n  fs.closeSync(packfile)\n  return new RawObject(OBJ_TYPES[type], data);\n}\n\nPackStorage.prototype.unpack_object = function(pack, packfile, offset, options) {\n  // Ensure valid options variable\n  options = options ? options : {};\n  var obj_offset = offset;\n  \n  // TODO TODO TODO TODO TODO TODO\n  // TODO TODO TODO TODO TODO TODO\n  // TODO TODO TODO TODO TODO TODO\n  \n  var buf = new Buffer(1);\n  fs.readSync(packfile, buf, 0, 1, offset);\n  // Fetch the first byte\n  var c = buf[0];  \n  var size = c & 0xf\n  var type = (c >> 4) & 7;\n  var shift = 4;\n  var offset = offset + 1;\n  // unpack until we have decoded size\n  while((c & 0x80) != 0) {\n    fs.readSync(packfile, buf, 0, 1, offset);\n    c = buf[0];\n    // Adjust size for the byte\n    size = size | ((c & 0x7f) << shift);\n    shift = shift + 7;\n    offset = offset + 1;\n  }\n  \n  // If it's not a commit or tree and caching is enabled then return false\n  if(!(type == OBJ_COMMIT || type == OBJ_TREE) && options['caching']) return [false, false];\n  // Check the type of object and either unpack the delta or the compressed data (gziped)\n  if(type == OBJ_OFS_DELTA || type == OBJ_REF_DELTA) {\n    return this.unpack_deltified(packfile, type, offset, obj_offset, size, options);\n  } else if(type == OBJ_COMMIT || type == OBJ_TREE || type == OBJ_BLOB || type == OBJ_TAG) {\n    var data = unpack_compressed(pack, offset, size);\n    return [data, type];\n  } else {\n    throw new \"invalid type \" + type;\n  }  \n}\n\nPackStorage.prototype.unpack_deltified = function(packfile, type, offset, obj_offset, size, options) {\n  var data = new Buffer(SHA1_SIZE);\n  // Read the SHA\n  fs.readSync(packfile, data, 0, SHA1_SIZE, offset);\n  \n  if(type == OBJ_OFS_DELTA) {\n    var i = 0;\n    var c = data[i];\n    var base_offset = c & 0x7f;\n    \n    while((c & 0x80) != 0) {\n      c = data[++i];\n      base_offset = base_offset + 1;\n      base_offset = base_offset << 7;\n      base_offset = base_offset | (c & 0x7f);\n    }\n    \n    base_offset = obj_offset - base_offset;\n    offset = offset + i + 1;\n  } else {\n    base_offset = find_object(this, data.toString())\n    offset = offset + SHA1_SIZE;\n  }\n  \n  // Fetch the object at this offset and unpack the result\n  var object_array = this.unpack_object(this, packfile, base_offset);\n  var base = object_array[0];\n  var type = object_array[1];\n  // If it's not a Commit or Tree return an empty delta\n  if(!(type == OBJ_COMMIT || type == OBJ_TREE) && options['caching']) return [false, false];\n  // Unpack the the data\n  var delta = unpack_compressed(this, offset, size);\n  var delta2 = patch_delta(base, delta);\n  return [delta2, type];\n}\n\nvar to_hex_string = function(string) {\n  var hexString = '';\n  for(var index = 0; index < string.length; index++) {\n    var value = BinaryParser.toByte(string.substr(index, 1));\n    var number = value <= 15 ? \"0\" + value.toString(16) : value.toString(16);\n    hexString = hexString + number;\n  }\n  return hexString;\n};\n\nvar patch_delta = function(base, delta) {\n  var delta_header_parts = patch_delta_header_size(delta, 0);\n  var src_size = delta_header_parts[0];\n  var pos = delta_header_parts[1];\n  \n  if(src_size != base.length) throw \"invalid delta data\";\n    \n  delta_header_parts = patch_delta_header_size(delta, pos);\n  var dest_size = delta_header_parts[0];\n  pos = delta_header_parts[1];\n  var dest = '';\n  \n  while(pos < delta.length) {\n    var c = delta.charCodeAt(pos);\n    pos = pos + 1;\n    \n    // Keep reading until end of data pack\n    if((c & 0x80) != 0) {\n      pos = pos - 1;\n      var cp_off = 0;\n      var cp_size = 0;\n      \n      if((c & 0x01) != 0) cp_off = delta.charCodeAt(pos += 1);\n      if((c & 0x02) != 0) cp_off = cp_off | (delta.charCodeAt(pos += 1) << 8);\n      if((c & 0x04) != 0) cp_off = cp_off | (delta.charCodeAt(pos += 1) << 16);\n      if((c & 0x08) != 0) cp_off = cp_off | (delta.charCodeAt(pos += 1) << 24);\n      \n      if((c & 0x10) != 0) cp_size = delta.charCodeAt(pos += 1);\n      if((c & 0x20) != 0) cp_size = cp_size | (delta.charCodeAt(pos += 1) << 8);\n      if((c & 0x40) != 0) cp_size = cp_size | (delta.charCodeAt(pos += 1) << 16);\n      if(cp_size == 0) cp_size = 0x10000;\n      \n      pos = pos + 1;\n      dest = dest + base.substr(cp_off, cp_size);\n    } else if(c != 0) {\n      dest = dest + delta.substr(pos, c);\n      pos = pos + c;\n    } else {\n      throw \"invalid delta data\";\n    }\n  }\n  \n  return dest;\n}\n\nvar patch_delta_header_size = function(delta, pos) {\n  var size = 0;\n  var shift = 0;\n\n  do {\n    var c = delta.charCodeAt(pos);\n    if(c == null) throw 'invalid delta data';\n    pos = pos + 1;\n    size = size | ((c & 0x7f) << shift);\n    shift = shift + 7\n    \n  } while((c & 0x80) != 0);\n  \n  // Return the header size and position\n  return [size, pos];\n}\n\nvar unpack_compressed = function(pack, offset, destsize) {\n  var outdata = \"\";\n  var file_offset = offset;\n  var packfile = fs.openSync(pack.name, \"r\");\n\n  // Read in the compressed object (this could be huge :() \n  // TODO TODO TODO, change unzip method to allow for initializing the structure and then decoding \n  // pieces\n  var indata = new Buffer(destsize + 100);\n  var bytes_read = fs.readSync(packfile, indata, 0, destsize + 100, file_offset);\n  // Close the file\n  fs.closeSync(packfile);\n  // Adjust the file_offset\n  file_offset = file_offset + destsize;  \n  outdata = outdata + new Zlib.Unzip(indata).unzip();\n\n  if(outdata.size > destsize) {    \n    throw \"error reading pack data\";\n  }\n  // Return the data read from the compressed block\n  return outdata;\n}\n\nvar find_object_in_index = function(pack, idx, sha1) {\n  // Parse the first value of the sha as an index\n  var slot = sha1.charCodeAt(0);\n  if(slot == NaN) return null;\n  \n  // Unpack the variables\n  var first = pack.offsets[slot];\n  var last = pack.offsets[slot + 1];\n  \n  while(first < last) {\n    var mid = parseInt((first + last) / 2);    \n    // If we have a version 2 pack file\n    if(pack.version == 2) {\n      // Fetch the sha1\n      var midsha1 = idx.index([(OFFSET_START + (mid * SHA1_SIZE)), SHA1_SIZE]);      \n      var compare_sha1 = '';\n      // Convert midsha1 to allow for correct string comparision\n      for(var i = 0; i < midsha1.length; i++) {\n        compare_sha1 = compare_sha1 + String.fromCharCode(midsha1[i]);\n      }\n\n      // Do a locale Compare\n      var cmp = compare_sha1.localeCompare(sha1);\n      if(cmp < 0) {\n        first = mid + 1;        \n      } else if(cmp > 0) {\n        last = mid;\n      } else {\n        var pos = OFFSET_START + (pack.size * (SHA1_SIZE + CRC_SIZE)) + (mid * OFFSET_SIZE);\n        var offset = idx.index([pos, OFFSET_SIZE]);\n        offset = BinaryParser.toInt(reverse_buffer(offset).toString('binary', 0, 4));\n        return offset;\n      }\n    } else {\n      var midsha1 = idx.index([SHA1_START + mid * ENTRY_SIZE, SHA1_SIZE]);\n      var compare_sha1 = '';\n      // Convert midsha1 to allow for correct string comparision\n      for(var i = 0; i < midsha1.length; i++) {\n        compare_sha1 = compare_sha1 + String.fromCharCode(midsha1[i]);\n      }\n\n      // Do a locale Compare\n      var cmp = compare_sha1.localeCompare(sha1);\n      if(cmp < 0) {\n        first = mid + 1;        \n      } else if(cmp > 0) {\n        last = mid;\n      } else {\n        var pos = OFFSET_START + mid * ENTRY_SIZE;\n        var offset = idx.index([pos, OFFSET_SIZE]);\n        offset = BinaryParser.toInt(reverse_buffer(offset).toString('binary', 0, 4));\n        return offset;\n      }      \n    }    \n  }  \n  return null;\n}\n\nvar find_object = function(pack, sha1) {\n  var obj = null;\n  // Should I not use the cached version in the future ? TODO\n  with_idx(pack, function(err, idx) {    \n    obj = find_object_in_index(pack, idx, sha1);\n  })\n  \n  return obj;\n}\n\nvar reverse_buffer = function(buffer) {\n  var result_buffer = new Buffer(buffer.length);\n  var length = buffer.length;\n  \n  for(var i = 0; i < length; i++) {\n    result_buffer[length - 1 - i] = buffer[i];\n  }\n  \n  return result_buffer;\n}\n\nvar init_pack = function(pack) {  \n  // TODO TODO TODO\n  with_idx(pack, function(err, idx) {\n    // Reset pack offsets\n    pack.offsets = [0];\n    // Do a max of FAN_OUT_COUNT to avoid going crazy\n    for(var i = 0; i < FAN_OUT_COUNT; i++) {\n      // Each offset value is a 4 byte network encoded integer\n      var pos = idx.index([i * IDX_OFFSET_SIZE, IDX_OFFSET_SIZE])      \n      pos = BinaryParser.toInt(reverse_buffer(pos).toString('binary', 0, 4));\n      // If the position is less than the pack offset stored the pack index is corrupt\n      if(pos < pack.offsets[i]) {        \n        throw \"pack \" + pack.name + \" has discontinuous index \" + i;\n      }\n      // Add offset position to list of tracked offsets\n      pack.offsets.push(pos);\n    }\n    // Adjust the pack size\n    pack.size = pack.offsets[pack.offsets.length - 1];\n    // Close all files\n    idx.close();\n  });\n}\n\nvar with_idx = function(pack, index_file, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  index_file = args.length ? args.shift() : null;\n  // Final idx file name\n  var idx_file_name = null;\n  // Define file handle variable\n  var idxfile = null;\n  \n  if(!index_file) {\n    index_file = pack.name;\n    idx_file_name = pack.name.substr(0, pack.name.length - 4) + \"idx\";\n    idxfile = fs.openSync(pack.name.substr(0, pack.name.length - 4) + \"idx\", \"r\");\n  } else {\n    idx_file_name = index_file;\n    idxfile = fs.openSync(index_file, \"r\");\n  }\n  \n  // Read header\n  var sign_buffer = new Buffer(4);\n  var signature = '';\n  fs.readSync(idxfile, sign_buffer, 0, 4);\n  for(var i = 0; i < sign_buffer.length;  i++) {\n    signature = signature + BinaryParser.fromByte(sign_buffer[i]);\n  }\n  \n  // Extract version of pack\n  var ver_buffer = new Buffer(4);\n  fs.readSync(idxfile, ver_buffer, 0, 4);\n  var ver = BinaryParser.toInt(reverse_buffer(ver_buffer).toString('binary', 0, 4));\n  // Close idx file\n  fs.closeSync(idxfile);  \n  // If we have a IDX pack signature this is at least version 2 of the file format\n  if(signature == PACK_IDX_SIGNATURE) {\n    if(ver != 2) {\n      throw (\"pack \" + pack.name + \" has unknown pack file version \" + ver);\n    }\n    pack.version = 2;\n  } else {\n    pack.version = 1;\n  }\n  // Create a file window and return it\n  var idx = new FileWindow(idx_file_name, pack.version);\n  callback(null, idx);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}