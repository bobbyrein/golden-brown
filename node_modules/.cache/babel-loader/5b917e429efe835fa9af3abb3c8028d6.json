{"ast":null,"code":"/*\n    Copyright 2008,2009\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @fileoverview Utilities for uncompressing and base64 decoding\n */\n\n/**\n  * @class Util class\n  * Class for gunzipping, unzipping and base64 decoding of files.\n  * It is used for reading GEONExT, Geogebra and Intergeo files.\n  *\n  * Only Huffman codes are decoded in gunzip.\n  * The code is based on the source code for gunzip.c by Pasi Ojala \n  * @see <a href=\"http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c\">http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c</a>\n  * @see <a href=\"http://www.cs.tut.fi/~albert\">http://www.cs.tut.fi/~albert</a>\n  */\nvar util = require('util');\nvar Zlib = exports.Zlib = {};\n\n/**\n * Unzip zip files\n */\nZlib.Unzip = function (barray) {\n  var outputArr = [],\n    output = \"\",\n    debug = false,\n    gpflags,\n    files = 0,\n    unzipped = [],\n    crc,\n    buf32k = new Array(32768),\n    bIdx = 0,\n    modeZIP = false,\n    CRC,\n    SIZE,\n    bitReverse = [0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff],\n    cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],\n    cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99],\n    /* 99==invalid */\n\n    cpdist = [0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001],\n    cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],\n    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    bA = barray,\n    bytepos = 0,\n    bitpos = 0,\n    bb = 1,\n    bits = 0,\n    NAMEMAX = 256,\n    nameBuf = [],\n    fileout;\n  function readByte() {\n    bits += 8;\n    if (bytepos < bA.length) {\n      //if (debug)\n      //    document.write(bytepos+\": \"+bA[bytepos]+\"<br>\");\n      // util.debug(bA[bytepos++].toString(16))\n      // return String.fromCharCode(bA[bytepos++]);\n      return bA[bytepos++];\n    } else return -1;\n  }\n  ;\n  function byteAlign() {\n    bb = 1;\n  }\n  ;\n  function readBit() {\n    var carry;\n    bits++;\n    carry = bb & 1;\n    bb >>= 1;\n    if (bb == 0) {\n      bb = readByte();\n      carry = bb & 1;\n      bb = bb >> 1 | 0x80;\n    }\n    return carry;\n  }\n  ;\n  function readBits(a) {\n    var res = 0,\n      i = a;\n    while (i--) {\n      res = res << 1 | readBit();\n    }\n    if (a) {\n      res = bitReverse[res] >> 8 - a;\n    }\n    return res;\n  }\n  ;\n  function flushBuffer() {\n    //document.write('FLUSHBUFFER:'+buf32k);\n    bIdx = 0;\n  }\n  ;\n  function addBuffer(a) {\n    SIZE++;\n    //CRC=updcrc(a,crc);\n    buf32k[bIdx++] = a;\n    outputArr.push(String.fromCharCode(a));\n    //output+=String.fromCharCode(a);\n    if (bIdx == 0x8000) {\n      //document.write('ADDBUFFER:'+buf32k);\n      bIdx = 0;\n    }\n  }\n  ;\n  function HufNode() {\n    this.b0 = 0;\n    this.b1 = 0;\n    this.jump = null;\n    this.jumppos = -1;\n  }\n  ;\n  var LITERALS = 288;\n  var literalTree = new Array(LITERALS);\n  var distanceTree = new Array(32);\n  var treepos = 0;\n  var Places = null;\n  var Places2 = null;\n  var impDistanceTree = new Array(64);\n  var impLengthTree = new Array(64);\n  var len = 0;\n  var fpos = new Array(17);\n  fpos[0] = 0;\n  var flens;\n  var fmax;\n  function IsPat() {\n    while (1) {\n      if (fpos[len] >= fmax) return -1;\n      if (flens[fpos[len]] == len) return fpos[len]++;\n      fpos[len]++;\n    }\n  }\n  ;\n  function Rec() {\n    var curplace = Places[treepos];\n    var tmp;\n    if (debug) util.debug(\"len: \" + len + \" treepos: \" + treepos);\n    if (len == 17) {\n      //war 17\n      return -1;\n    }\n    treepos++;\n    len++;\n    tmp = IsPat();\n    if (debug) util.debug(\"IsPat \" + tmp);\n    if (tmp >= 0) {\n      curplace.b0 = tmp; /* leaf cell for 0-bit */\n      if (debug) util.debug(\"b0 \" + curplace.b0);\n    } else {\n      /* Not a Leaf cell */\n      curplace.b0 = 0x8000;\n      if (debug) util.debug(\"b0 \" + curplace.b0);\n      if (Rec()) return -1;\n    }\n    tmp = IsPat();\n    if (tmp >= 0) {\n      curplace.b1 = tmp; /* leaf cell for 1-bit */\n      if (debug) util.debug(\"b1 \" + curplace.b1);\n      curplace.jump = null; /* Just for the display routine */\n    } else {\n      /* Not a Leaf cell */\n      curplace.b1 = 0x8000;\n      if (debug) util.debug(\"b1 \" + curplace.b1);\n      curplace.jump = Places[treepos];\n      curplace.jumppos = treepos;\n      if (Rec()) return -1;\n    }\n    len--;\n    return 0;\n  }\n  ;\n  function CreateTree(currentTree, numval, lengths, show) {\n    var i;\n    /* Create the Huffman decode tree/table */\n    //document.write(\"<br>createtree<br>\");\n    if (debug) util.debug(\"currentTree \" + currentTree + \" numval \" + numval + \" lengths \" + lengths + \" show \" + show);\n    Places = currentTree;\n    treepos = 0;\n    flens = lengths;\n    fmax = numval;\n    for (i = 0; i < 17; i++) fpos[i] = 0;\n    len = 0;\n    if (Rec()) {\n      //fprintf(stderr, \"invalid huffman tree\\n\");\n      if (debug) util.debug(\"invalid huffman tree\");\n      return -1;\n    }\n    if (debug) {\n      util.debug(\"Tree: \" + Places.length);\n      for (var a = 0; a < 32; a++) {\n        util.debug(\"Places[\" + a + \"].b0=\" + Places[a].b0);\n        util.debug(\"Places[\" + a + \"].b1=\" + Places[a].b1);\n      }\n    }\n\n    /*if(show) {\n        var tmp;\n        for(tmp=currentTree;tmp<Places;tmp++) {\n            fprintf(stdout, \"0x%03x  0x%03x (0x%04x)\",tmp-currentTree, tmp->jump?tmp->jump-currentTree:0,(tmp->jump?tmp->jump-currentTree:0)*6+0xcf0);\n            if(!(tmp.b0 & 0x8000)) {\n                //fprintf(stdout, \"  0x%03x (%c)\", tmp->b0,(tmp->b0<256 && isprint(tmp->b0))?tmp->b0:'�');\n            }\n            if(!(tmp.b1 & 0x8000)) {\n                if((tmp.b0 & 0x8000))\n                    fprintf(stdout, \"           \");\n                fprintf(stdout, \"  0x%03x (%c)\", tmp->b1,(tmp->b1<256 && isprint(tmp->b1))?tmp->b1:'�');\n            }\n            fprintf(stdout, \"\\n\");\n        }\n    }*/\n    return 0;\n  }\n  ;\n  function DecodeValue(currentTree) {\n    var len,\n      i,\n      xtreepos = 0,\n      X = currentTree[xtreepos],\n      b;\n\n    /* decode one symbol of the data */\n    while (1) {\n      b = readBit();\n      if (debug) util.debug(\"b=\" + b);\n      if (b) {\n        if (!(X.b1 & 0x8000)) {\n          if (debug) util.debug(\"ret1\");\n          return X.b1; /* If leaf node, return data */\n        }\n\n        X = X.jump;\n        len = currentTree.length;\n        for (i = 0; i < len; i++) {\n          if (currentTree[i] === X) {\n            xtreepos = i;\n            break;\n          }\n        }\n        //xtreepos++;\n      } else {\n        if (!(X.b0 & 0x8000)) {\n          if (debug) util.debug(\"ret2\");\n          return X.b0; /* If leaf node, return data */\n        }\n        //X++; //??????????????????\n        xtreepos++;\n        X = currentTree[xtreepos];\n      }\n    }\n    if (debug) util.debug(\"ret3\");\n    return -1;\n  }\n  ;\n  function DeflateLoop() {\n    var last, c, type, i, len;\n    do {\n      /*if((last = readBit())){\n          fprintf(errfp, \"Last Block: \");\n      } else {\n          fprintf(errfp, \"Not Last Block: \");\n      }*/\n      last = readBit();\n      type = readBits(2);\n      switch (type) {\n        case 0:\n          if (debug) util.debug(\"Stored\");\n          break;\n        case 1:\n          if (debug) util.debug(\"Fixed Huffman codes\");\n          break;\n        case 2:\n          if (debug) util.debug(\"Dynamic Huffman codes\");\n          break;\n        case 3:\n          if (debug) util.debug(\"Reserved block type!!\");\n          break;\n        default:\n          if (debug) util.debug(\"Unexpected value \" + type);\n          break;\n      }\n      if (type == 0) {\n        var blockLen, cSum;\n\n        // Stored \n        byteAlign();\n        blockLen = readByte();\n        blockLen |= readByte() << 8;\n        cSum = readByte();\n        cSum |= readByte() << 8;\n        if ((blockLen ^ ~cSum) & 0xffff) {\n          util.debug(\"BlockLen checksum mismatch\");\n        }\n        while (blockLen--) {\n          c = readByte();\n          addBuffer(c);\n        }\n      } else if (type == 1) {\n        var j;\n\n        /* Fixed Huffman tables -- fixed decode routine */\n        while (1) {\n          /*\n              256    0000000        0\n              :   :     :\n              279    0010111        23\n              0   00110000    48\n              :    :      :\n              143    10111111    191\n              280 11000000    192\n              :    :      :\n              287 11000111    199\n              144    110010000    400\n              :    :       :\n              255    111111111    511\n                   Note the bit order!\n              */\n\n          j = bitReverse[readBits(7)] >> 1;\n          if (j > 23) {\n            j = j << 1 | readBit(); /* 48..255 */\n\n            if (j > 199) {\n              /* 200..255 */\n              j -= 128; /*  72..127 */\n              j = j << 1 | readBit(); /* 144..255 << */\n            } else {\n              /*  48..199 */\n              j -= 48; /*   0..151 */\n              if (j > 143) {\n                j = j + 136; /* 280..287 << */\n                /*   0..143 << */\n              }\n            }\n          } else {\n            /*   0..23 */\n            j += 256; /* 256..279 << */\n          }\n\n          if (j < 256) {\n            addBuffer(j);\n            //document.write(\"out:\"+String.fromCharCode(j));\n            /*fprintf(errfp, \"@%d %02x\\n\", SIZE, j);*/\n          } else if (j == 256) {\n            /* EOF */\n            break;\n          } else {\n            var len, dist;\n            j -= 256 + 1; /* bytes + EOF */\n            len = readBits(cplext[j]) + cplens[j];\n            j = bitReverse[readBits(5)] >> 3;\n            if (cpdext[j] > 8) {\n              dist = readBits(8);\n              dist |= readBits(cpdext[j] - 8) << 8;\n            } else {\n              dist = readBits(cpdext[j]);\n            }\n            dist += cpdist[j];\n\n            /*fprintf(errfp, \"@%d (l%02x,d%04x)\\n\", SIZE, len, dist);*/\n            for (j = 0; j < len; j++) {\n              var c = buf32k[bIdx - dist & 0x7fff];\n              addBuffer(c);\n            }\n          }\n        } // while\n      } else if (type == 2) {\n        var j, n, literalCodes, distCodes, lenCodes;\n        var ll = new Array(288 + 32); // \"static\" just to preserve stack\n\n        // Dynamic Huffman tables \n\n        literalCodes = 257 + readBits(5);\n        distCodes = 1 + readBits(5);\n        lenCodes = 4 + readBits(4);\n        //document.write(\"<br>param: \"+literalCodes+\" \"+distCodes+\" \"+lenCodes+\"<br>\");\n        for (j = 0; j < 19; j++) {\n          ll[j] = 0;\n        }\n\n        // Get the decode tree code lengths\n\n        //document.write(\"<br>\");\n        for (j = 0; j < lenCodes; j++) {\n          ll[border[j]] = readBits(3);\n          //document.write(ll[border[j]]+\" \");\n        }\n        //fprintf(errfp, \"\\n\");\n        //document.write('<br>ll:'+ll);\n        len = distanceTree.length;\n        for (i = 0; i < len; i++) distanceTree[i] = new HufNode();\n        if (CreateTree(distanceTree, 19, ll, 0)) {\n          flushBuffer();\n          return 1;\n        }\n        if (debug) {\n          util.debug(\"distanceTree\");\n          for (var a = 0; a < distanceTree.length; a++) {\n            util.debug(\"\" + distanceTree[a].b0 + \" \" + distanceTree[a].b1 + \" \" + distanceTree[a].jump + \" \" + distanceTree[a].jumppos);\n            /*if (distanceTree[a].jumppos!=-1)\n               \tdocument.write(\" \"+distanceTree[a].jump.b0+\" \"+distanceTree[a].jump.b1);\n            */\n          }\n        }\n        //document.write('<BR>tree created');\n\n        //read in literal and distance code lengths\n        n = literalCodes + distCodes;\n        i = 0;\n        var z = -1;\n        if (debug) util.debug(\"n=\" + n + \" bits: \" + bits);\n        while (i < n) {\n          z++;\n          j = DecodeValue(distanceTree);\n          if (debug) util.debug(\"\" + z + \" i:\" + i + \" decode: \" + j + \"    bits\" + bits);\n          if (j < 16) {\n            // length of code in bits (0..15)\n            ll[i++] = j;\n          } else if (j == 16) {\n            // repeat last length 3 to 6 times \n            var l;\n            j = 3 + readBits(2);\n            if (i + j > n) {\n              flushBuffer();\n              return 1;\n            }\n            l = i ? ll[i - 1] : 0;\n            while (j--) {\n              ll[i++] = l;\n            }\n          } else {\n            if (j == 17) {\n              // 3 to 10 zero length codes\n              j = 3 + readBits(3);\n            } else {\n              // j == 18: 11 to 138 zero length codes \n              j = 11 + readBits(7);\n            }\n            if (i + j > n) {\n              flushBuffer();\n              return 1;\n            }\n            while (j--) {\n              ll[i++] = 0;\n            }\n          }\n        }\n        /*for(j=0; j<literalCodes+distCodes; j++) {\n            //fprintf(errfp, \"%d \", ll[j]);\n            if ((j&7)==7)\n                fprintf(errfp, \"\\n\");\n        }\n        fprintf(errfp, \"\\n\");*/\n        // Can overwrite tree decode tree as it is not used anymore\n        len = literalTree.length;\n        for (i = 0; i < len; i++) literalTree[i] = new HufNode();\n        if (CreateTree(literalTree, literalCodes, ll, 0)) {\n          flushBuffer();\n          return 1;\n        }\n        len = literalTree.length;\n        for (i = 0; i < len; i++) distanceTree[i] = new HufNode();\n        var ll2 = new Array();\n        for (i = literalCodes; i < ll.length; i++) {\n          ll2[i - literalCodes] = ll[i];\n        }\n        if (CreateTree(distanceTree, distCodes, ll2, 0)) {\n          flushBuffer();\n          return 1;\n        }\n        if (debug) util.debug(\"literalTree\");\n        while (1) {\n          j = DecodeValue(literalTree);\n          if (j >= 256) {\n            // In C64: if carry set\n            var len, dist;\n            j -= 256;\n            if (j == 0) {\n              // EOF\n              break;\n            }\n            j--;\n            len = readBits(cplext[j]) + cplens[j];\n            j = DecodeValue(distanceTree);\n            if (cpdext[j] > 8) {\n              dist = readBits(8);\n              dist |= readBits(cpdext[j] - 8) << 8;\n            } else {\n              dist = readBits(cpdext[j]);\n            }\n            dist += cpdist[j];\n            while (len--) {\n              var c = buf32k[bIdx - dist & 0x7fff];\n              addBuffer(c);\n            }\n          } else {\n            addBuffer(j);\n          }\n        }\n      }\n    } while (!last);\n    flushBuffer();\n    byteAlign();\n    return 0;\n  }\n  ;\n  Zlib.Unzip.prototype.unzipFile = function (name) {\n    var i;\n    this.unzip();\n    //alert(unzipped[0][1]);\n    for (i = 0; i < unzipped.length; i++) {\n      if (unzipped[i][1] == name) {\n        return unzipped[i][0];\n      }\n    }\n  };\n  Zlib.Unzip.prototype.unzip = function () {\n    //convertToByteArray(input);\n    if (debug) util.debug(bA);\n    /*for (i=0;i<bA.length*8;i++){\n    \tdocument.write(readBit());\n    \tif ((i+1)%8==0)\n    \t\tdocument.write(\" \");\n    }*/\n    /*for (i=0;i<bA.length;i++){\n    \tdocument.write(readByte()+\" \");\n    \tif ((i+1)%8==0)\n    \t\tdocument.write(\" \");\n    }\n    for (i=0;i<bA.length;i++){\n    \tdocument.write(bA[i]+\" \");\n    \tif ((i+1)%16==0)\n    \t\tdocument.write(\"<br>\");\n    }\t\n    */\n    //alert(bA);\n    nextFile();\n    return unzipped;\n  };\n  function nextFile() {\n    if (debug) util.debug(\"NEXTFILE\");\n    outputArr = [];\n    var tmp = [];\n    modeZIP = false;\n    tmp[0] = readByte();\n    tmp[1] = readByte();\n    if (debug) util.debug(\"type: \" + tmp[0] + \" \" + tmp[1]);\n    if (tmp[0] == parseInt(\"78\", 16) && (tmp[1] == parseInt(\"156\", 10) || tmp[1] == parseInt(\"1\", 10))) {\n      //GZIP\n      if (debug) util.debug(\"GEONExT-GZIP\");\n      DeflateLoop();\n      if (debug) util.debug(outputArr.join(''));\n      // unzipped[files] = new Array(2);\n      unzipped[files] = outputArr.join('');\n      files++;\n    }\n    if (tmp[0] == parseInt(\"1f\", 16) && tmp[1] == parseInt(\"8b\", 16)) {\n      //GZIP\n      if (debug) util.debug(\"GZIP\");\n      //DeflateLoop();\n      skipdir();\n      if (debug) util.debug(outputArr.join(''));\n      unzipped[files] = new Array(2);\n      unzipped[files][0] = outputArr.join('');\n      unzipped[files][1] = \"file\";\n      files++;\n    }\n    if (tmp[0] == parseInt(\"50\", 16) && tmp[1] == parseInt(\"4b\", 16)) {\n      //ZIP\n      modeZIP = true;\n      tmp[2] = readByte();\n      tmp[3] = readByte();\n      if (tmp[2] == parseInt(\"3\", 16) && tmp[3] == parseInt(\"4\", 16)) {\n        //MODE_ZIP\n        tmp[0] = readByte();\n        tmp[1] = readByte();\n        if (debug) util.debug(\"ZIP-Version: \" + tmp[1] + \" \" + tmp[0] / 10 + \".\" + tmp[0] % 10);\n        gpflags = readByte();\n        gpflags |= readByte() << 8;\n        if (debug) util.debug(\"gpflags: \" + gpflags);\n        var method = readByte();\n        method |= readByte() << 8;\n        if (debug) util.debug(\"method: \" + method);\n        readByte();\n        readByte();\n        readByte();\n        readByte();\n        var crc = readByte();\n        crc |= readByte() << 8;\n        crc |= readByte() << 16;\n        crc |= readByte() << 24;\n        var compSize = readByte();\n        compSize |= readByte() << 8;\n        compSize |= readByte() << 16;\n        compSize |= readByte() << 24;\n        var size = readByte();\n        size |= readByte() << 8;\n        size |= readByte() << 16;\n        size |= readByte() << 24;\n        if (debug) util.debug(\"local CRC: \" + crc + \"\\nlocal Size: \" + size + \"\\nlocal CompSize: \" + compSize);\n        var filelen = readByte();\n        filelen |= readByte() << 8;\n        var extralen = readByte();\n        extralen |= readByte() << 8;\n        if (debug) util.debug(\"filelen \" + filelen);\n        i = 0;\n        nameBuf = [];\n        while (filelen--) {\n          var c = readByte();\n          if (c == \"/\" | c == \":\") {\n            i = 0;\n          } else if (i < NAMEMAX - 1) nameBuf[i++] = String.fromCharCode(c);\n        }\n        if (debug) util.debug(\"nameBuf: \" + nameBuf);\n\n        //nameBuf[i] = \"\\0\";\n        if (!fileout) fileout = nameBuf;\n        var i = 0;\n        while (i < extralen) {\n          c = readByte();\n          i++;\n        }\n        CRC = 0xffffffff;\n        SIZE = 0;\n        if (size = 0 && fileOut.charAt(fileout.length - 1) == \"/\") {\n          //skipdir\n          if (debug) util.debug(\"skipdir\");\n        }\n        if (method == 8) {\n          DeflateLoop();\n          if (debug) util.debug(outputArr.join(''));\n          unzipped[files] = new Array(2);\n          unzipped[files][0] = outputArr.join('');\n          unzipped[files][1] = nameBuf.join('');\n          files++;\n          //return outputArr.join('');\n        }\n\n        skipdir();\n      }\n    }\n  }\n  ;\n  function skipdir() {\n    var crc,\n      tmp = [],\n      compSize,\n      size,\n      os,\n      i,\n      c;\n    if (gpflags & 8) {\n      tmp[0] = readByte();\n      tmp[1] = readByte();\n      tmp[2] = readByte();\n      tmp[3] = readByte();\n      if (tmp[0] == parseInt(\"50\", 16) && tmp[1] == parseInt(\"4b\", 16) && tmp[2] == parseInt(\"07\", 16) && tmp[3] == parseInt(\"08\", 16)) {\n        crc = readByte();\n        crc |= readByte() << 8;\n        crc |= readByte() << 16;\n        crc |= readByte() << 24;\n      } else {\n        crc = tmp[0] | tmp[1] << 8 | tmp[2] << 16 | tmp[3] << 24;\n      }\n      compSize = readByte();\n      compSize |= readByte() << 8;\n      compSize |= readByte() << 16;\n      compSize |= readByte() << 24;\n      size = readByte();\n      size |= readByte() << 8;\n      size |= readByte() << 16;\n      size |= readByte() << 24;\n      if (debug) util.debug(\"CRC:\");\n    }\n    if (modeZIP) nextFile();\n    tmp[0] = readByte();\n    if (tmp[0] != 8) {\n      if (debug) util.debug(\"Unknown compression method!\");\n      return 0;\n    }\n    gpflags = readByte();\n    if (debug) {\n      if (gpflags & ~parseInt(\"1f\", 16)) util.debug(\"Unknown flags set!\");\n    }\n    readByte();\n    readByte();\n    readByte();\n    readByte();\n    readByte();\n    os = readByte();\n    if (gpflags & 4) {\n      tmp[0] = readByte();\n      tmp[2] = readByte();\n      len = tmp[0] + 256 * tmp[1];\n      if (debug) util.debug(\"Extra field size: \" + len);\n      for (i = 0; i < len; i++) readByte();\n    }\n    if (gpflags & 8) {\n      i = 0;\n      nameBuf = [];\n      while (c = readByte()) {\n        if (c == \"7\" || c == \":\") i = 0;\n        if (i < NAMEMAX - 1) nameBuf[i++] = c;\n      }\n      //nameBuf[i] = \"\\0\";\n      if (debug) util.debug(\"original file name: \" + nameBuf);\n    }\n    if (gpflags & 16) {\n      while (c = readByte()) {\n        //FILE COMMENT\n      }\n    }\n    if (gpflags & 2) {\n      readByte();\n      readByte();\n    }\n    DeflateLoop();\n    crc = readByte();\n    crc |= readByte() << 8;\n    crc |= readByte() << 16;\n    crc |= readByte() << 24;\n    size = readByte();\n    size |= readByte() << 8;\n    size |= readByte() << 16;\n    size |= readByte() << 24;\n    if (modeZIP) nextFile();\n  }\n  ;\n};\n\n/**\n*  Base64 encoding / decoding\n*  @see <a href=\"http://www.webtoolkit.info/\">http://www.webtoolkit.info/</A>\n*/\nZlib.Base64 = {\n  // private property\n  _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n  // public method for encoding\n  encode: function (input) {\n    var output = [],\n      chr1,\n      chr2,\n      chr3,\n      enc1,\n      enc2,\n      enc3,\n      enc4,\n      i = 0;\n    input = Zlib.Base64._utf8_encode(input);\n    while (i < input.length) {\n      chr1 = input.charCodeAt(i++);\n      chr2 = input.charCodeAt(i++);\n      chr3 = input.charCodeAt(i++);\n      enc1 = chr1 >> 2;\n      enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n      enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n      enc4 = chr3 & 63;\n      if (isNaN(chr2)) {\n        enc3 = enc4 = 64;\n      } else if (isNaN(chr3)) {\n        enc4 = 64;\n      }\n      output.push([this._keyStr.charAt(enc1), this._keyStr.charAt(enc2), this._keyStr.charAt(enc3), this._keyStr.charAt(enc4)].join(''));\n    }\n    return output.join('');\n  },\n  // public method for decoding\n  decode: function (input, utf8) {\n    var output = [],\n      chr1,\n      chr2,\n      chr3,\n      enc1,\n      enc2,\n      enc3,\n      enc4,\n      i = 0;\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n    while (i < input.length) {\n      enc1 = this._keyStr.indexOf(input.charAt(i++));\n      enc2 = this._keyStr.indexOf(input.charAt(i++));\n      enc3 = this._keyStr.indexOf(input.charAt(i++));\n      enc4 = this._keyStr.indexOf(input.charAt(i++));\n      chr1 = enc1 << 2 | enc2 >> 4;\n      chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n      chr3 = (enc3 & 3) << 6 | enc4;\n      output.push(String.fromCharCode(chr1));\n      if (enc3 != 64) {\n        output.push(String.fromCharCode(chr2));\n      }\n      if (enc4 != 64) {\n        output.push(String.fromCharCode(chr3));\n      }\n    }\n    output = output.join('');\n    if (utf8) {\n      output = Zlib.Base64._utf8_decode(output);\n    }\n    return output;\n  },\n  // private method for UTF-8 encoding\n  _utf8_encode: function (string) {\n    string = string.replace(/\\r\\n/g, \"\\n\");\n    var utftext = \"\";\n    for (var n = 0; n < string.length; n++) {\n      var c = string.charCodeAt(n);\n      if (c < 128) {\n        utftext += String.fromCharCode(c);\n      } else if (c > 127 && c < 2048) {\n        utftext += String.fromCharCode(c >> 6 | 192);\n        utftext += String.fromCharCode(c & 63 | 128);\n      } else {\n        utftext += String.fromCharCode(c >> 12 | 224);\n        utftext += String.fromCharCode(c >> 6 & 63 | 128);\n        utftext += String.fromCharCode(c & 63 | 128);\n      }\n    }\n    return utftext;\n  },\n  // private method for UTF-8 decoding\n  _utf8_decode: function (utftext) {\n    var string = [],\n      i = 0,\n      c = 0,\n      c2 = 0,\n      c3 = 0;\n    while (i < utftext.length) {\n      c = utftext.charCodeAt(i);\n      if (c < 128) {\n        string.push(String.fromCharCode(c));\n        i++;\n      } else if (c > 191 && c < 224) {\n        c2 = utftext.charCodeAt(i + 1);\n        string.push(String.fromCharCode((c & 31) << 6 | c2 & 63));\n        i += 2;\n      } else {\n        c2 = utftext.charCodeAt(i + 1);\n        c3 = utftext.charCodeAt(i + 2);\n        string.push(String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63));\n        i += 3;\n      }\n    }\n    return string.join('');\n  },\n  _destrip: function (stripped, wrap) {\n    var lines = [],\n      lineno,\n      i,\n      destripped = [];\n    if (wrap == null) wrap = 76;\n    stripped.replace(/ /g, \"\");\n    lineno = stripped.length / wrap;\n    for (i = 0; i < lineno; i++) lines[i] = stripped.substr(i * wrap, wrap);\n    if (lineno != stripped.length / wrap) lines[lines.length] = stripped.substr(lineno * wrap, stripped.length - lineno * wrap);\n    for (i = 0; i < lines.length; i++) destripped.push(lines[i]);\n    return destripped.join('\\n');\n  },\n  decodeAsArray: function (input) {\n    var dec = this.decode(input),\n      ar = [],\n      i;\n    for (i = 0; i < dec.length; i++) {\n      ar[i] = dec.charCodeAt(i);\n    }\n    return ar;\n  },\n  decodeGEONExT: function (input) {\n    return decodeAsArray(destrip(input), false);\n  }\n};\n\n/**\n * @private\n */\nZlib.asciiCharCodeAt = function (str, i) {\n  var c = str.charCodeAt(i);\n  if (c > 255) {\n    switch (c) {\n      case 8364:\n        c = 128;\n        break;\n      case 8218:\n        c = 130;\n        break;\n      case 402:\n        c = 131;\n        break;\n      case 8222:\n        c = 132;\n        break;\n      case 8230:\n        c = 133;\n        break;\n      case 8224:\n        c = 134;\n        break;\n      case 8225:\n        c = 135;\n        break;\n      case 710:\n        c = 136;\n        break;\n      case 8240:\n        c = 137;\n        break;\n      case 352:\n        c = 138;\n        break;\n      case 8249:\n        c = 139;\n        break;\n      case 338:\n        c = 140;\n        break;\n      case 381:\n        c = 142;\n        break;\n      case 8216:\n        c = 145;\n        break;\n      case 8217:\n        c = 146;\n        break;\n      case 8220:\n        c = 147;\n        break;\n      case 8221:\n        c = 148;\n        break;\n      case 8226:\n        c = 149;\n        break;\n      case 8211:\n        c = 150;\n        break;\n      case 8212:\n        c = 151;\n        break;\n      case 732:\n        c = 152;\n        break;\n      case 8482:\n        c = 153;\n        break;\n      case 353:\n        c = 154;\n        break;\n      case 8250:\n        c = 155;\n        break;\n      case 339:\n        c = 156;\n        break;\n      case 382:\n        c = 158;\n        break;\n      case 376:\n        c = 159;\n        break;\n      default:\n        break;\n    }\n  }\n  return c;\n};\n\n/**\n * Decoding string into utf-8\n * @param {String} string to decode\n * @return {String} utf8 decoded string\n */\nZlib.utf8Decode = function (utftext) {\n  var string = [];\n  var i = 0;\n  var c = 0,\n    c1 = 0,\n    c2 = 0;\n  while (i < utftext.length) {\n    c = utftext.charCodeAt(i);\n    if (c < 128) {\n      string.push(String.fromCharCode(c));\n      i++;\n    } else if (c > 191 && c < 224) {\n      c2 = utftext.charCodeAt(i + 1);\n      string.push(String.fromCharCode((c & 31) << 6 | c2 & 63));\n      i += 2;\n    } else {\n      c2 = utftext.charCodeAt(i + 1);\n      c3 = utftext.charCodeAt(i + 2);\n      string.push(String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63));\n      i += 3;\n    }\n  }\n  ;\n  return string.join('');\n};","map":{"version":3,"names":["util","require","Zlib","exports","Unzip","barray","outputArr","output","debug","gpflags","files","unzipped","crc","buf32k","Array","bIdx","modeZIP","CRC","SIZE","bitReverse","cplens","cplext","cpdist","cpdext","border","bA","bytepos","bitpos","bb","bits","NAMEMAX","nameBuf","fileout","readByte","length","byteAlign","readBit","carry","readBits","a","res","i","flushBuffer","addBuffer","push","String","fromCharCode","HufNode","b0","b1","jump","jumppos","LITERALS","literalTree","distanceTree","treepos","Places","Places2","impDistanceTree","impLengthTree","len","fpos","flens","fmax","IsPat","Rec","curplace","tmp","CreateTree","currentTree","numval","lengths","show","DecodeValue","xtreepos","X","b","DeflateLoop","last","c","type","blockLen","cSum","j","dist","n","literalCodes","distCodes","lenCodes","ll","z","l","ll2","prototype","unzipFile","name","unzip","nextFile","parseInt","join","skipdir","method","compSize","size","filelen","extralen","fileOut","charAt","os","Base64","_keyStr","encode","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","_utf8_encode","charCodeAt","isNaN","decode","utf8","replace","indexOf","_utf8_decode","string","utftext","c2","c3","_destrip","stripped","wrap","lines","lineno","destripped","substr","decodeAsArray","dec","ar","decodeGEONExT","destrip","asciiCharCodeAt","str","utf8Decode","c1"],"sources":["/Users/bobbyrein/react-course/golden-brown/node_modules/git/lib/zlib/zlib.js"],"sourcesContent":["/*\n    Copyright 2008,2009\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @fileoverview Utilities for uncompressing and base64 decoding\n */\n\n/**\n  * @class Util class\n  * Class for gunzipping, unzipping and base64 decoding of files.\n  * It is used for reading GEONExT, Geogebra and Intergeo files.\n  *\n  * Only Huffman codes are decoded in gunzip.\n  * The code is based on the source code for gunzip.c by Pasi Ojala \n  * @see <a href=\"http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c\">http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c</a>\n  * @see <a href=\"http://www.cs.tut.fi/~albert\">http://www.cs.tut.fi/~albert</a>\n  */\nvar util = require('util');\nvar Zlib = exports.Zlib = {};\n      \n/**\n * Unzip zip files\n */\nZlib.Unzip = function (barray){\n    var outputArr = [],\n        output = \"\",\n        debug = false,\n        gpflags,\n        files = 0,\n        unzipped = [],\n        crc,\n        buf32k = new Array(32768),\n        bIdx = 0,\n        modeZIP=false,\n\n        CRC, SIZE,\n    \n        bitReverse = [\n        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,\n        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,\n        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,\n        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,\n        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,\n        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,\n        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,\n        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,\n        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,\n        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,\n        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,\n        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,\n        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,\n        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\n        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,\n        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,\n        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,\n        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,\n        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,\n        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,\n        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,\n        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,\n        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,\n        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,\n        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,\n        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,\n        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,\n        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\n        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,\n        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,\n        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,\n        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff\n    ],\n    \n    cplens = [\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n    ],\n\n    cplext = [\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99\n    ], /* 99==invalid */\n\n    cpdist = [\n        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,\n        0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,\n        0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,\n        0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001\n    ],\n\n    cpdext = [\n        0,  0,  0,  0,  1,  1,  2,  2,\n        3,  3,  4,  4,  5,  5,  6,  6,\n        7,  7,  8,  8,  9,  9, 10, 10,\n        11, 11, 12, 12, 13, 13\n    ],\n    \n    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    \n    bA = barray,\n\n    bytepos=0,\n    bitpos=0,\n    bb = 1,\n    bits=0,\n    \n    NAMEMAX = 256,\n    \n    nameBuf = [],\n    \n    fileout;\n    \n    function readByte(){\n        bits+=8;\n        if (bytepos<bA.length){\n            //if (debug)\n            //    document.write(bytepos+\": \"+bA[bytepos]+\"<br>\");\n            // util.debug(bA[bytepos++].toString(16))\n            // return String.fromCharCode(bA[bytepos++]);\n            return bA[bytepos++];\n        } else\n            return -1;\n    };\n\n    function byteAlign(){\n        bb = 1;\n    };\n    \n    function readBit(){\n        var carry;\n        bits++;\n        carry = (bb & 1);\n        bb >>= 1;\n        if (bb==0){\n            bb = readByte();\n            carry = (bb & 1);\n            bb = (bb>>1) | 0x80;\n        }\n        return carry;\n    };\n\n    function readBits(a) {\n        var res = 0,\n            i = a;\n    \n        while(i--) {\n            res = (res<<1) | readBit();\n        }\n        if(a) {\n            res = bitReverse[res]>>(8-a);\n        }\n        return res;\n    };\n        \n    function flushBuffer(){\n        //document.write('FLUSHBUFFER:'+buf32k);\n        bIdx = 0;\n    };\n    function addBuffer(a){\n        SIZE++;\n        //CRC=updcrc(a,crc);\n        buf32k[bIdx++] = a;\n        outputArr.push(String.fromCharCode(a));\n        //output+=String.fromCharCode(a);\n        if(bIdx==0x8000){\n            //document.write('ADDBUFFER:'+buf32k);\n            bIdx=0;\n        }\n    };\n    \n    function HufNode() {\n        this.b0=0;\n        this.b1=0;\n        this.jump = null;\n        this.jumppos = -1;\n    };\n\n    var LITERALS = 288;\n    \n    var literalTree = new Array(LITERALS);\n    var distanceTree = new Array(32);\n    var treepos=0;\n    var Places = null;\n    var Places2 = null;\n    \n    var impDistanceTree = new Array(64);\n    var impLengthTree = new Array(64);\n    \n    var len = 0;\n    var fpos = new Array(17);\n    fpos[0]=0;\n    var flens;\n    var fmax;\n    \n    function IsPat() {\n        while (1) {\n            if (fpos[len] >= fmax)\n                return -1;\n            if (flens[fpos[len]] == len)\n                return fpos[len]++;\n            fpos[len]++;\n        }\n    };\n\n    function Rec() {\n        var curplace = Places[treepos];\n        var tmp;\n        if (debug)\n          util.debug(\"len: \" + len + \" treepos: \" + treepos)\n        if(len==17) { //war 17\n            return -1;\n        }\n        treepos++;\n        len++;\n    \t\n        tmp = IsPat();\n        if (debug)\n          util.debug(\"IsPat \" + tmp)\n        if(tmp >= 0) {\n            curplace.b0 = tmp;    /* leaf cell for 0-bit */\n            if (debug)\n              util.debug(\"b0 \" + curplace.b0)\n        } else {\n        /* Not a Leaf cell */\n        curplace.b0 = 0x8000;\n        if (debug)\n          util.debug(\"b0 \" + curplace.b0)\n        if(Rec())\n            return -1;\n        }\n        tmp = IsPat();\n        if(tmp >= 0) {\n            curplace.b1 = tmp;    /* leaf cell for 1-bit */\n            if (debug)\n              util.debug(\"b1 \" + curplace.b1);\n            curplace.jump = null;    /* Just for the display routine */\n        } else {\n            /* Not a Leaf cell */\n            curplace.b1 = 0x8000;\n            if (debug)\n              util.debug(\"b1 \" + curplace.b1);\n            curplace.jump = Places[treepos];\n            curplace.jumppos = treepos;\n            if(Rec())\n                return -1;\n        }\n        len--;\n        return 0;\n    };\n\n    function CreateTree(currentTree, numval, lengths, show) {\n        var i;\n        /* Create the Huffman decode tree/table */\n        //document.write(\"<br>createtree<br>\");\n        if (debug)\n          util.debug(\"currentTree \" + currentTree + \" numval \" + numval + \" lengths \" + lengths + \" show \" + show);\n        Places = currentTree;\n        treepos=0;\n        flens = lengths;\n        fmax  = numval;\n        for (i=0;i<17;i++)\n            fpos[i] = 0;\n        len = 0;\n        if(Rec()) {\n            //fprintf(stderr, \"invalid huffman tree\\n\");\n            if (debug)\n              util.debug(\"invalid huffman tree\");\n            return -1;\n        }\n        if (debug){\n          util.debug(\"Tree: \" + Places.length);\n        \tfor (var a=0;a<32;a++){\n        \t  util.debug(\"Places[\" + a + \"].b0=\" + Places[a].b0);\n        \t  util.debug(\"Places[\" + a + \"].b1=\" + Places[a].b1);\n        \t}\n        }\n    \n        /*if(show) {\n            var tmp;\n            for(tmp=currentTree;tmp<Places;tmp++) {\n                fprintf(stdout, \"0x%03x  0x%03x (0x%04x)\",tmp-currentTree, tmp->jump?tmp->jump-currentTree:0,(tmp->jump?tmp->jump-currentTree:0)*6+0xcf0);\n                if(!(tmp.b0 & 0x8000)) {\n                    //fprintf(stdout, \"  0x%03x (%c)\", tmp->b0,(tmp->b0<256 && isprint(tmp->b0))?tmp->b0:'�');\n                }\n                if(!(tmp.b1 & 0x8000)) {\n                    if((tmp.b0 & 0x8000))\n                        fprintf(stdout, \"           \");\n                    fprintf(stdout, \"  0x%03x (%c)\", tmp->b1,(tmp->b1<256 && isprint(tmp->b1))?tmp->b1:'�');\n                }\n                fprintf(stdout, \"\\n\");\n            }\n        }*/\n        return 0;\n    };\n    \n    function DecodeValue(currentTree) {\n        var len, i,\n            xtreepos=0,\n            X = currentTree[xtreepos],\n            b;\n\n        /* decode one symbol of the data */\n        while(1) {\n            b=readBit();\n            if (debug)\n              util.debug(\"b=\" + b);\n            if(b) {\n                if(!(X.b1 & 0x8000)){\n                \tif (debug)\n                \t  util.debug(\"ret1\");\n                    return X.b1;    /* If leaf node, return data */\n                }\n                X = X.jump;\n                len = currentTree.length;\n                for (i=0;i<len;i++){\n                    if (currentTree[i]===X){\n                        xtreepos=i;\n                        break;\n                    }\n                }\n                //xtreepos++;\n            } else {\n                if(!(X.b0 & 0x8000)){\n                \tif (debug)\n                \t  util.debug(\"ret2\");\n                    return X.b0;    /* If leaf node, return data */\n                }\n                //X++; //??????????????????\n                xtreepos++;\n                X = currentTree[xtreepos];\n            }\n        }\n        if (debug)\n          util.debug(\"ret3\");\n        return -1;\n    };\n    \n    function DeflateLoop() {\n    var last, c, type, i, len;\n\n    do {\n        /*if((last = readBit())){\n            fprintf(errfp, \"Last Block: \");\n        } else {\n            fprintf(errfp, \"Not Last Block: \");\n        }*/\n        last = readBit();\n        type = readBits(2);\n        \n        switch(type) {\n            case 0:\n            \tif (debug)\n            \t    util.debug(\"Stored\");\n                break;\n            case 1:\n            \tif (debug)\n                  util.debug(\"Fixed Huffman codes\");\n                break;\n            case 2:\n            \tif (debug)\n            \t    util.debug(\"Dynamic Huffman codes\");\n                break;\n            case 3:\n            \tif (debug)\n                  util.debug(\"Reserved block type!!\");\n                break;\n            default:\n            \tif (debug)\n                  util.debug(\"Unexpected value \" + type);\n                break;\n        }\n        \n        if(type==0) {\n            var blockLen, cSum;\n\n            // Stored \n            byteAlign();\n            blockLen = readByte();\n            blockLen |= (readByte()<<8);\n\n            cSum = readByte();\n            cSum |= (readByte()<<8);\n\n            if(((blockLen ^ ~cSum) & 0xffff)) {\n              util.debug(\"BlockLen checksum mismatch\");\n            }\n            while(blockLen--) {\n                c = readByte();\n                addBuffer(c);\n            }\n        } else if(type==1) {\n            var j;\n\n            /* Fixed Huffman tables -- fixed decode routine */\n            while(1) {\n            /*\n                256    0000000        0\n                :   :     :\n                279    0010111        23\n                0   00110000    48\n                :    :      :\n                143    10111111    191\n                280 11000000    192\n                :    :      :\n                287 11000111    199\n                144    110010000    400\n                :    :       :\n                255    111111111    511\n    \n                Note the bit order!\n                */\n\n            j = (bitReverse[readBits(7)]>>1);\n            if(j > 23) {\n                j = (j<<1) | readBit();    /* 48..255 */\n\n                if(j > 199) {    /* 200..255 */\n                    j -= 128;    /*  72..127 */\n                    j = (j<<1) | readBit();        /* 144..255 << */\n                } else {        /*  48..199 */\n                    j -= 48;    /*   0..151 */\n                    if(j > 143) {\n                        j = j+136;    /* 280..287 << */\n                        /*   0..143 << */\n                    }\n                }\n            } else {    /*   0..23 */\n                j += 256;    /* 256..279 << */\n            }\n            if(j < 256) {\n                addBuffer(j);\n                //document.write(\"out:\"+String.fromCharCode(j));\n                /*fprintf(errfp, \"@%d %02x\\n\", SIZE, j);*/\n            } else if(j == 256) {\n                /* EOF */\n                break;\n            } else {\n                var len, dist;\n\n                j -= 256 + 1;    /* bytes + EOF */\n                len = readBits(cplext[j]) + cplens[j];\n\n                j = bitReverse[readBits(5)]>>3;\n                if(cpdext[j] > 8) {\n                    dist = readBits(8);\n                    dist |= (readBits(cpdext[j]-8)<<8);\n                } else {\n                    dist = readBits(cpdext[j]);\n                }\n                dist += cpdist[j];\n\n                /*fprintf(errfp, \"@%d (l%02x,d%04x)\\n\", SIZE, len, dist);*/\n                for(j=0;j<len;j++) {\n                    var c = buf32k[(bIdx - dist) & 0x7fff];\n                    addBuffer(c);\n                }\n            }\n            } // while\n        } else if(type==2) {\n            var j, n, literalCodes, distCodes, lenCodes;\n            var ll = new Array(288+32);    // \"static\" just to preserve stack\n    \n            // Dynamic Huffman tables \n    \n            literalCodes = 257 + readBits(5);\n            distCodes = 1 + readBits(5);\n            lenCodes = 4 + readBits(4);\n            //document.write(\"<br>param: \"+literalCodes+\" \"+distCodes+\" \"+lenCodes+\"<br>\");\n            for(j=0; j<19; j++) {\n                ll[j] = 0;\n            }\n    \n            // Get the decode tree code lengths\n    \n            //document.write(\"<br>\");\n            for(j=0; j<lenCodes; j++) {\n                ll[border[j]] = readBits(3);\n                //document.write(ll[border[j]]+\" \");\n            }\n            //fprintf(errfp, \"\\n\");\n            //document.write('<br>ll:'+ll);\n            len = distanceTree.length;\n            for (i=0; i<len; i++)\n                distanceTree[i]=new HufNode();\n            if(CreateTree(distanceTree, 19, ll, 0)) {\n                flushBuffer();\n                return 1;\n            }\n            if (debug){\n              util.debug(\"distanceTree\");\n            \tfor(var a=0;a<distanceTree.length;a++){\n                  util.debug(\"\" + distanceTree[a].b0 + \" \" + distanceTree[a].b1 + \" \" + distanceTree[a].jump + \" \" + distanceTree[a].jumppos);\n                \t/*if (distanceTree[a].jumppos!=-1)\n                    \tdocument.write(\" \"+distanceTree[a].jump.b0+\" \"+distanceTree[a].jump.b1);\n                \t*/\n            \t}\n            }\n            //document.write('<BR>tree created');\n    \n            //read in literal and distance code lengths\n            n = literalCodes + distCodes;\n            i = 0;\n            var z=-1;\n            if (debug)\n              util.debug(\"n=\" + n + \" bits: \" + bits);\n            while(i < n) {\n                z++;\n                j = DecodeValue(distanceTree);\n                if (debug)\n                  util.debug(\"\" + z + \" i:\" + i + \" decode: \" + j + \"    bits\" + bits);\n                if(j<16) {    // length of code in bits (0..15)\n                       ll[i++] = j;\n                } else if(j==16) {    // repeat last length 3 to 6 times \n                       var l;\n                    j = 3 + readBits(2);\n                    if(i+j > n) {\n                        flushBuffer();\n                        return 1;\n                    }\n                    l = i ? ll[i-1] : 0;\n                    while(j--) {\n                        ll[i++] = l;\n                    }\n                } else {\n                    if(j==17) {        // 3 to 10 zero length codes\n                        j = 3 + readBits(3);\n                    } else {        // j == 18: 11 to 138 zero length codes \n                        j = 11 + readBits(7);\n                    }\n                    if(i+j > n) {\n                        flushBuffer();\n                        return 1;\n                    }\n                    while(j--) {\n                        ll[i++] = 0;\n                    }\n                }\n            }\n            /*for(j=0; j<literalCodes+distCodes; j++) {\n                //fprintf(errfp, \"%d \", ll[j]);\n                if ((j&7)==7)\n                    fprintf(errfp, \"\\n\");\n            }\n            fprintf(errfp, \"\\n\");*/\n            // Can overwrite tree decode tree as it is not used anymore\n            len = literalTree.length;\n            for (i=0; i<len; i++)\n                literalTree[i]=new HufNode();\n            if(CreateTree(literalTree, literalCodes, ll, 0)) {\n                flushBuffer();\n                return 1;\n            }\n            len = literalTree.length;\n            for (i=0; i<len; i++)\n                distanceTree[i]=new HufNode();\n            var ll2 = new Array();\n            for (i=literalCodes; i <ll.length; i++){\n                ll2[i-literalCodes]=ll[i];\n            }    \n            if(CreateTree(distanceTree, distCodes, ll2, 0)) {\n                flushBuffer();\n                return 1;\n            }\n            if (debug)\n              util.debug(\"literalTree\");\n            while(1) {\n                j = DecodeValue(literalTree);\n                if(j >= 256) {        // In C64: if carry set\n                    var len, dist;\n                    j -= 256;\n                    if(j == 0) {\n                        // EOF\n                        break;\n                    }\n                    j--;\n                    len = readBits(cplext[j]) + cplens[j];\n    \n                    j = DecodeValue(distanceTree);\n                    if(cpdext[j] > 8) {\n                        dist = readBits(8);\n                        dist |= (readBits(cpdext[j]-8)<<8);\n                    } else {\n                        dist = readBits(cpdext[j]);\n                    }\n                    dist += cpdist[j];\n                    while(len--) {\n                        var c = buf32k[(bIdx - dist) & 0x7fff];\n                        addBuffer(c);\n                    }\n                } else {\n                    addBuffer(j);\n                }\n            }\n        }\n    } while(!last);\n    flushBuffer();\n\n    byteAlign();\n    return 0;\n};\n\nZlib.Unzip.prototype.unzipFile = function(name) {\n    var i;\n\tthis.unzip();\n\t//alert(unzipped[0][1]);\n\tfor (i=0;i<unzipped.length;i++){\n\t\tif(unzipped[i][1]==name) {\n\t\t\treturn unzipped[i][0];\n\t\t}\n\t}\n\t\n  };\n    \n    \nZlib.Unzip.prototype.unzip = function() {\n\t//convertToByteArray(input);\n\tif (debug)\n\t  util.debug(bA);\n\t/*for (i=0;i<bA.length*8;i++){\n\t\tdocument.write(readBit());\n\t\tif ((i+1)%8==0)\n\t\t\tdocument.write(\" \");\n\t}*/\n\t/*for (i=0;i<bA.length;i++){\n\t\tdocument.write(readByte()+\" \");\n\t\tif ((i+1)%8==0)\n\t\t\tdocument.write(\" \");\n\t}\n\tfor (i=0;i<bA.length;i++){\n\t\tdocument.write(bA[i]+\" \");\n\t\tif ((i+1)%16==0)\n\t\t\tdocument.write(\"<br>\");\n\t}\t\n\t*/\n\t//alert(bA);\n\tnextFile();\n\treturn unzipped;\n  };\n    \n function nextFile(){\n \tif (debug)\n \t  util.debug(\"NEXTFILE\");\n \toutputArr = [];\n \tvar tmp = [];\n \tmodeZIP = false;\n\ttmp[0] = readByte();\n\ttmp[1] = readByte();\n\t\n\tif (debug)\n\t  util.debug(\"type: \" + tmp[0] + \" \" + tmp[1]);\n\tif (tmp[0] == parseInt(\"78\",16) && (tmp[1] == parseInt(\"156\",10) || tmp[1] == parseInt(\"1\", 10))){ //GZIP\n\t\tif (debug)\n\t\t  util.debug(\"GEONExT-GZIP\");\n\t\tDeflateLoop();\n\t\tif (debug)\n\t    util.debug(outputArr.join(''));\n    // unzipped[files] = new Array(2);\n    \tunzipped[files] = outputArr.join('');\n    \tfiles++;\n\t}\n\tif (tmp[0] == parseInt(\"1f\",16) && tmp[1] == parseInt(\"8b\",16)){ //GZIP\n\t\tif (debug)\n      util.debug(\"GZIP\");\n\t\t//DeflateLoop();\n\t\tskipdir();\n\t\tif (debug)\n      util.debug(outputArr.join(''));\n\t\tunzipped[files] = new Array(2);\n    \tunzipped[files][0] = outputArr.join('');\n    \tunzipped[files][1] = \"file\";\n    \tfiles++;\n\t}\n\tif (tmp[0] == parseInt(\"50\",16) && tmp[1] == parseInt(\"4b\",16)){ //ZIP\n\t\tmodeZIP = true;\n\t\ttmp[2] = readByte();\n\t\ttmp[3] = readByte();\n\t\tif (tmp[2] == parseInt(\"3\",16) && tmp[3] == parseInt(\"4\",16)){\n\t\t\t//MODE_ZIP\n\t\t\ttmp[0] = readByte();\n\t\t\ttmp[1] = readByte();\n\t\t\tif (debug)\n        util.debug(\"ZIP-Version: \"+tmp[1]+\" \"+tmp[0]/10+\".\"+tmp[0]%10);\n\t\t\t\n\t\t\tgpflags = readByte();\n\t\t\tgpflags |= (readByte()<<8);\n\t\t\tif (debug)\n        util.debug(\"gpflags: \"+gpflags);\n\t\t\t\n\t\t\tvar method = readByte();\n\t\t\tmethod |= (readByte()<<8);\n\t\t\tif (debug)\n        util.debug(\"method: \"+method);\n\t\t\t\n\t\t\treadByte();\n\t\t\treadByte();\n\t\t\treadByte();\n\t\t\treadByte();\n\t\t\t\n\t\t\tvar crc = readByte();\n\t\t\tcrc |= (readByte()<<8);\n\t\t\tcrc |= (readByte()<<16);\n\t\t\tcrc |= (readByte()<<24);\n\t\t\t\n\t\t\tvar compSize = readByte();\n\t\t\tcompSize |= (readByte()<<8);\n\t\t\tcompSize |= (readByte()<<16);\n\t\t\tcompSize |= (readByte()<<24);\n\t\t\t\n\t\t\tvar size = readByte();\n\t\t\tsize |= (readByte()<<8);\n\t\t\tsize |= (readByte()<<16);\n\t\t\tsize |= (readByte()<<24);\n\t\t\t\n\t\t\tif (debug)\n\t\t\t  util.debug(\"local CRC: \"+crc+\"\\nlocal Size: \"+size+\"\\nlocal CompSize: \"+compSize);\n\t\t\t\n\t\t\tvar filelen = readByte();\n\t\t\tfilelen |= (readByte()<<8);\n\t\t\t\n\t\t\tvar extralen = readByte();\n\t\t\textralen |= (readByte()<<8);\n\t\t\t\n\t\t\tif (debug)\n\t\t\t  util.debug(\"filelen \"+filelen);\n\t\t\ti = 0;\n\t\t\tnameBuf = [];\n\t\t\twhile (filelen--){ \n\t\t\t\tvar c = readByte();\n\t\t\t\tif (c == \"/\" | c ==\":\"){\n\t\t\t\t\ti = 0;\n\t\t\t\t} else if (i < NAMEMAX-1)\n\t\t\t\t\tnameBuf[i++] = String.fromCharCode(c);\n\t\t\t}\n\t\t\tif (debug)\n\t\t\t  util.debug(\"nameBuf: \"+nameBuf);\n\t\t\t\n\t\t\t//nameBuf[i] = \"\\0\";\n\t\t\tif (!fileout)\n\t\t\t\tfileout = nameBuf;\n\t\t\t\n\t\t\tvar i = 0;\n\t\t\twhile (i < extralen){\n\t\t\t\tc = readByte();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\t\n\t\t\tCRC = 0xffffffff;\n\t\t\tSIZE = 0;\n\t\t\t\n\t\t\tif (size = 0 && fileOut.charAt(fileout.length-1)==\"/\"){\n\t\t\t\t//skipdir\n\t\t\t\tif (debug)\n\t\t\t\t  util.debug(\"skipdir\");\n\t\t\t}\n\t\t\tif (method == 8){\n\t\t\t\tDeflateLoop();\n\t\t\t\tif (debug)\n\t\t\t\t  util.debug(outputArr.join(''));\n\t\t\t\tunzipped[files] = new Array(2);\n\t\t\t\tunzipped[files][0] = outputArr.join('');\n    \t\t\tunzipped[files][1] = nameBuf.join('');\n    \t\t\tfiles++;\n\t\t\t\t//return outputArr.join('');\n\t\t\t}\n\t\t\tskipdir();\n\t\t}\n\t}\n };\n\t\nfunction skipdir(){\n    var crc, \n        tmp = [],\n        compSize, size, os, i, c;\n    \n\tif ((gpflags & 8)) {\n\t\ttmp[0] = readByte();\n\t\ttmp[1] = readByte();\n\t\ttmp[2] = readByte();\n\t\ttmp[3] = readByte();\n\t\t\n\t\tif (tmp[0] == parseInt(\"50\",16) && \n            tmp[1] == parseInt(\"4b\",16) && \n            tmp[2] == parseInt(\"07\",16) && \n            tmp[3] == parseInt(\"08\",16))\n        {\n            crc = readByte();\n            crc |= (readByte()<<8);\n            crc |= (readByte()<<16);\n            crc |= (readByte()<<24);\n\t\t} else {\n\t\t\tcrc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);\n\t\t}\n\t\t\n\t\tcompSize = readByte();\n\t\tcompSize |= (readByte()<<8);\n\t\tcompSize |= (readByte()<<16);\n\t\tcompSize |= (readByte()<<24);\n\t\t\n\t\tsize = readByte();\n\t\tsize |= (readByte()<<8);\n\t\tsize |= (readByte()<<16);\n\t\tsize |= (readByte()<<24);\n\t\t\n\t\tif (debug)\n\t\t  util.debug(\"CRC:\");\n\t}\n\n\tif (modeZIP)\n\t\tnextFile();\n\t\n\ttmp[0] = readByte();\n\tif (tmp[0] != 8) {\n\t\tif (debug)\n\t\t  util.debug(\"Unknown compression method!\");\n        return 0;\t\n\t}\n\t\n\tgpflags = readByte();\n\tif (debug){\n\t\tif ((gpflags & ~(parseInt(\"1f\",16))))\n\t\t  util.debug(\"Unknown flags set!\");\n\t}\n\t\n\treadByte();\n\treadByte();\n\treadByte();\n\treadByte();\n\t\n\treadByte();\n\tos = readByte();\n\t\n\tif ((gpflags & 4)){\n\t\ttmp[0] = readByte();\n\t\ttmp[2] = readByte();\n\t\tlen = tmp[0] + 256*tmp[1];\n\t\tif (debug)\n\t\t  util.debug(\"Extra field size: \"+len);\n\t\tfor (i=0;i<len;i++)\n\t\t\treadByte();\n\t}\n\t\n\tif ((gpflags & 8)){\n\t\ti=0;\n\t\tnameBuf=[];\n\t\twhile (c=readByte()){\n\t\t\tif(c == \"7\" || c == \":\")\n\t\t\t\ti=0;\n\t\t\tif (i<NAMEMAX-1)\n\t\t\t\tnameBuf[i++] = c;\n\t\t}\n\t\t//nameBuf[i] = \"\\0\";\n\t\tif (debug)\n\t\t  util.debug(\"original file name: \"+nameBuf);\n\t}\n\t\t\n\tif ((gpflags & 16)){\n\t\twhile (c=readByte()){\n\t\t\t//FILE COMMENT\n\t\t}\n\t}\n\t\n\tif ((gpflags & 2)){\n\t\treadByte();\n\t\treadByte();\n\t}\n\t\n\tDeflateLoop();\n\t\n\tcrc = readByte();\n\tcrc |= (readByte()<<8);\n\tcrc |= (readByte()<<16);\n\tcrc |= (readByte()<<24);\n\t\n\tsize = readByte();\n\tsize |= (readByte()<<8);\n\tsize |= (readByte()<<16);\n\tsize |= (readByte()<<24);\n\t\n\tif (modeZIP)\n\t\tnextFile();\n\t\n};\n\n};\n\n/**\n*  Base64 encoding / decoding\n*  @see <a href=\"http://www.webtoolkit.info/\">http://www.webtoolkit.info/</A>\n*/\nZlib.Base64 = {\n\n    // private property\n    _keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n\n    // public method for encoding\n    encode : function (input) {\n        var output = [],\n            chr1, chr2, chr3, enc1, enc2, enc3, enc4,\n            i = 0;\n\n        input = Zlib.Base64._utf8_encode(input);\n\n        while (i < input.length) {\n\n            chr1 = input.charCodeAt(i++);\n            chr2 = input.charCodeAt(i++);\n            chr3 = input.charCodeAt(i++);\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) {\n                enc3 = enc4 = 64;\n            } else if (isNaN(chr3)) {\n                enc4 = 64;\n            }\n\n            output.push([this._keyStr.charAt(enc1),\n                         this._keyStr.charAt(enc2),\n                         this._keyStr.charAt(enc3),\n                         this._keyStr.charAt(enc4)].join(''));\n        }\n\n        return output.join('');\n    },\n\n    // public method for decoding\n    decode : function (input, utf8) {\n        var output = [],\n            chr1, chr2, chr3,\n            enc1, enc2, enc3, enc4,\n            i = 0;\n\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n        while (i < input.length) {\n\n            enc1 = this._keyStr.indexOf(input.charAt(i++));\n            enc2 = this._keyStr.indexOf(input.charAt(i++));\n            enc3 = this._keyStr.indexOf(input.charAt(i++));\n            enc4 = this._keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output.push(String.fromCharCode(chr1));\n\n            if (enc3 != 64) {\n                output.push(String.fromCharCode(chr2));\n            }\n            if (enc4 != 64) {\n                output.push(String.fromCharCode(chr3));\n            }\n        }\n        \n        output = output.join(''); \n        \n        if (utf8) {\n            output = Zlib.Base64._utf8_decode(output);\n        }\n        return output;\n\n    },\n\n    // private method for UTF-8 encoding\n    _utf8_encode : function (string) {\n        string = string.replace(/\\r\\n/g,\"\\n\");\n        var utftext = \"\";\n\n        for (var n = 0; n < string.length; n++) {\n\n            var c = string.charCodeAt(n);\n\n            if (c < 128) {\n                utftext += String.fromCharCode(c);\n            }\n            else if((c > 127) && (c < 2048)) {\n                utftext += String.fromCharCode((c >> 6) | 192);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n            else {\n                utftext += String.fromCharCode((c >> 12) | 224);\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n\n        }\n\n        return utftext;\n    },\n\n    // private method for UTF-8 decoding\n    _utf8_decode : function (utftext) {\n        var string = [],\n            i = 0,\n            c = 0, c2 = 0, c3 = 0;\n\n        while ( i < utftext.length ) {\n            c = utftext.charCodeAt(i);\n            if (c < 128) {\n                string.push(String.fromCharCode(c));\n                i++;\n            }\n            else if((c > 191) && (c < 224)) {\n                c2 = utftext.charCodeAt(i+1);\n                string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));\n                i += 2;\n            }\n            else {\n                c2 = utftext.charCodeAt(i+1);\n                c3 = utftext.charCodeAt(i+2);\n                string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));\n                i += 3;\n            }\n        }\n        return string.join('');\n    },\n    \n    _destrip: function (stripped, wrap){\n        var lines = [], lineno, i,\n            destripped = [];\n        \n        if (wrap==null) \n            wrap = 76;\n            \n        stripped.replace(/ /g, \"\");\n        lineno = stripped.length / wrap;\n        for (i = 0; i < lineno; i++)\n            lines[i]=stripped.substr(i * wrap, wrap);\n        if (lineno != stripped.length / wrap)\n            lines[lines.length]=stripped.substr(lineno * wrap, stripped.length-(lineno * wrap));\n            \n        for (i = 0; i < lines.length; i++)\n            destripped.push(lines[i]);\n        return destripped.join('\\n');\n    },\n    \n    decodeAsArray: function (input){\n        var dec = this.decode(input),\n            ar = [], i;\n        for (i=0;i<dec.length;i++){\n            ar[i]=dec.charCodeAt(i);\n        }\n        return ar;\n    },\n    \n    decodeGEONExT : function (input) {\n        return decodeAsArray(destrip(input),false);\n    }\n};\n\n/**\n * @private\n */\nZlib.asciiCharCodeAt = function(str,i){\n\tvar c = str.charCodeAt(i);\n\tif (c>255){\n    \tswitch (c) {\n\t\t\tcase 8364: c=128;\n\t    \tbreak;\n\t    \tcase 8218: c=130;\n\t    \tbreak;\n\t    \tcase 402: c=131;\n\t    \tbreak;\n\t    \tcase 8222: c=132;\n\t    \tbreak;\n\t    \tcase 8230: c=133;\n\t    \tbreak;\n\t    \tcase 8224: c=134;\n\t    \tbreak;\n\t    \tcase 8225: c=135;\n\t    \tbreak;\n\t    \tcase 710: c=136;\n\t    \tbreak;\n\t    \tcase 8240: c=137;\n\t    \tbreak;\n\t    \tcase 352: c=138;\n\t    \tbreak;\n\t    \tcase 8249: c=139;\n\t    \tbreak;\n\t    \tcase 338: c=140;\n\t    \tbreak;\n\t    \tcase 381: c=142;\n\t    \tbreak;\n\t    \tcase 8216: c=145;\n\t    \tbreak;\n\t    \tcase 8217: c=146;\n\t    \tbreak;\n\t    \tcase 8220: c=147;\n\t    \tbreak;\n\t    \tcase 8221: c=148;\n\t    \tbreak;\n\t    \tcase 8226: c=149;\n\t    \tbreak;\n\t    \tcase 8211: c=150;\n\t    \tbreak;\n\t    \tcase 8212: c=151;\n\t    \tbreak;\n\t    \tcase 732: c=152;\n\t    \tbreak;\n\t    \tcase 8482: c=153;\n\t    \tbreak;\n\t    \tcase 353: c=154;\n\t    \tbreak;\n\t    \tcase 8250: c=155;\n\t    \tbreak;\n\t    \tcase 339: c=156;\n\t    \tbreak;\n\t    \tcase 382: c=158;\n\t    \tbreak;\n\t    \tcase 376: c=159;\n\t    \tbreak;\n\t    \tdefault:\n\t    \tbreak;\n\t    }\n\t}\n\treturn c;\n};\n\n/**\n * Decoding string into utf-8\n * @param {String} string to decode\n * @return {String} utf8 decoded string\n */\nZlib.utf8Decode = function(utftext) {\n  var string = [];\n  var i = 0;\n  var c = 0, c1 = 0, c2 = 0;\n\n  while ( i < utftext.length ) {\n    c = utftext.charCodeAt(i);\n\n    if (c < 128) {\n      string.push(String.fromCharCode(c));\n      i++;\n    } else if((c > 191) && (c < 224)) {\n      c2 = utftext.charCodeAt(i+1);\n      string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));\n      i += 2;\n    } else {\n      c2 = utftext.charCodeAt(i+1);\n      c3 = utftext.charCodeAt(i+2);\n      string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));\n      i += 3;\n    }\n  };\n  return string.join('');\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIC,IAAI,GAAGC,OAAO,CAACD,IAAI,GAAG,CAAC,CAAC;;AAE5B;AACA;AACA;AACAA,IAAI,CAACE,KAAK,GAAG,UAAUC,MAAM,EAAC;EAC1B,IAAIC,SAAS,GAAG,EAAE;IACdC,MAAM,GAAG,EAAE;IACXC,KAAK,GAAG,KAAK;IACbC,OAAO;IACPC,KAAK,GAAG,CAAC;IACTC,QAAQ,GAAG,EAAE;IACbC,GAAG;IACHC,MAAM,GAAG,IAAIC,KAAK,CAAC,KAAK,CAAC;IACzBC,IAAI,GAAG,CAAC;IACRC,OAAO,GAAC,KAAK;IAEbC,GAAG;IAAEC,IAAI;IAETC,UAAU,GAAG,CACb,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9C,IAAI,EAAE,IAAI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"},"metadata":{},"sourceType":"script"}