{"ast":null,"code":"var util = require('util'),\n  SequenceCallbacks = require('./callbacks').SequenceCallbacks,\n  ContextChange = require('./change').ContextChange,\n  Change = require('./change').Change,\n  DiffCallbacks = require('./callbacks').DiffCallbacks,\n  SDiffCallbacks = require('./callbacks').SDiffCallbacks,\n  BalancedCallbacks = require('./callbacks').BalancedCallbacks,\n  ContextDiffCallbacks = require('./callbacks').ContextDiffCallbacks,\n  Hunk = require('./hunk').Hunk;\nvar Difference = exports.Difference = function () {};\nDifference.LCS = function () {};\n\n// Scope the Sequence Callbacks class\nDifference.LCS.SequenceCallbacks = SequenceCallbacks;\nDifference.LCS.ContextChange = ContextChange;\nDifference.LCS.DiffCallbacks = DiffCallbacks;\nDifference.LCS.SDiffCallbacks = SDiffCallbacks;\nDifference.LCS.BalancedCallbacks = BalancedCallbacks;\nDifference.LCS.ContextDiffCallbacks = ContextDiffCallbacks;\nDifference.LCS.Change = Change;\nDifference.LCS.Hunk = Hunk;\n\n// Diff::LCS.sdiff computes all necessary components to show two sequences\n// and their minimized differences side by side, just like the Unix\n// utility <em>sdiff</em> does:\n//\n//     old        <     -\n//     same             same\n//     before     |     after\n//     -          >     new\n//\n// See Diff::LCS::SDiffCallbacks for the default behaviour. An alternate\n// behaviour may be implemented with Diff::LCS::ContextDiffCallbacks. If\n// a Class argument is provided for +callbacks+, //diff will attempt to\n// initialise it. If the +callbacks+ object (possibly initialised)\n// responds to //finish, it will be called.\nDifference.LCS.sdiff = function (seq1, seq2, callbacks, block) {\n  callbacks = callbacks != null ? callbacks : Difference.LCS.SDiffCallbacks;\n  if (Object.prototype.toString.call(callbacks) == \"[object Function]\") {\n    callbacks = new callbacks();\n  }\n\n  // Traverse the sequence\n  Difference.LCS.traverse_balanced(seq1, seq2, callbacks);\n  if (callbacks.finish != null) callbacks.finish();\n  if (block != null) {\n    var res = callbacks.diffs.map(function (hunk) {\n      if (Array.isArray(hunk)) {\n        hunk = hunk.map(function (v) {\n          return block(v);\n        });\n      } else {\n        block(hunk);\n      }\n    });\n    return res;\n  } else {\n    return callbacks.diffs;\n  }\n};\n\n// Diff::LCS.diff computes the smallest set of additions and deletions\n// necessary to turn the first sequence into the second, and returns a\n// description of these changes.\n// \n// See Diff::LCS::DiffCallbacks for the default behaviour. An alternate\n// behaviour may be implemented with Diff::LCS::ContextDiffCallbacks.\n// If a Class argument is provided for +callbacks+, //diff will attempt\n// to initialise it. If the +callbacks+ object (possibly initialised)\n// responds to //finish, it will be called.\nDifference.LCS.diff = function (seq1, seq2, callbacks, block) {\n  callbacks = callbacks != null ? callbacks : Difference.LCS.DiffCallbacks;\n  if (Object.prototype.toString.call(callbacks) == \"[object Function]\") {\n    callbacks = new callbacks();\n  }\n\n  // Traverse the sequence\n  Difference.LCS.traverse_sequences(seq1, seq2, callbacks);\n  if (callbacks.finish != null) callbacks.finish();\n  if (block != null) {\n    var res = callbacks.diffs.map(function (hunk) {\n      if (Array.isArray(hunk)) {\n        hunk = hunk.map(function (v) {\n          return block(v);\n        });\n      } else {\n        block(hunk);\n      }\n    });\n    return res;\n  } else {\n    return callbacks.diffs;\n  }\n};\n\n// Diff::LCS.traverse_sequences is the most general facility provided by this\n// module; +diff+ and +LCS+ are implemented as calls to it.\n//\n// The arguments to //traverse_sequences are the two sequences to\n// traverse, and a callback object, like this:\n//\n//   traverse_sequences(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)\n//\n// //diff is implemented with //traverse_sequences.\n//\n// == Callback Methods\n// Optional callback methods are <em>emphasized</em>.\n//\n// callbacks//match::               Called when +a+ and +b+ are pointing\n//                                 to common elements in +A+ and +B+.\n// callbacks//discard_a::           Called when +a+ is pointing to an\n//                                 element not in +B+.\n// callbacks//discard_b::           Called when +b+ is pointing to an\n//                                 element not in +A+.\n// <em>callbacks//finished_a</em>:: Called when +a+ has reached the end of\n//                                 sequence +A+.\n// <em>callbacks//finished_b</em>:: Called when +b+ has reached the end of\n//                                 sequence +B+.\n//\n// == Algorithm\n//       a---+\n//           v\n//       A = a b c e h j l m n p\n//       B = b c d e f j k l m r s t\n//           ^\n//       b---+\n//\n// If there are two arrows (+a+ and +b+) pointing to elements of\n// sequences +A+ and +B+, the arrows will initially point to the first\n// elements of their respective sequences. //traverse_sequences will\n// advance the arrows through the sequences one element at a time,\n// calling a method on the user-specified callback object before each\n// advance. It will advance the arrows in such a way that if there are\n// elements <tt>A[ii]</tt> and <tt>B[jj]</tt> which are both equal and\n// part of the longest common subsequence, there will be some moment\n// during the execution of //traverse_sequences when arrow +a+ is pointing\n// to <tt>A[ii]</tt> and arrow +b+ is pointing to <tt>B[jj]</tt>. When\n// this happens, //traverse_sequences will call <tt>callbacks//match</tt>\n// and then it will advance both arrows.\n//\n// Otherwise, one of the arrows is pointing to an element of its sequence\n// that is not part of the longest common subsequence.\n// //traverse_sequences will advance that arrow and will call\n// <tt>callbacks//discard_a</tt> or <tt>callbacks//discard_b</tt>, depending\n// on which arrow it advanced. If both arrows point to elements that are\n// not part of the longest common subsequence, then //traverse_sequences\n// will advance one of them and call the appropriate callback, but it is\n// not specified which it will call.\n//\n// The methods for <tt>callbacks//match</tt>, <tt>callbacks//discard_a</tt>,\n// and <tt>callbacks//discard_b</tt> are invoked with an event comprising\n// the action (\"=\", \"+\", or \"-\", respectively), the indicies +ii+ and\n// +jj+, and the elements <tt>A[ii]</tt> and <tt>B[jj]</tt>. Return\n// values are discarded by //traverse_sequences.\n//\n// === End of Sequences\n// If arrow +a+ reaches the end of its sequence before arrow +b+ does,\n// //traverse_sequence try to call <tt>callbacks//finished_a</tt> with the\n// last index and element of +A+ (<tt>A[-1]</tt>) and the current index\n// and element of +B+ (<tt>B[jj]</tt>). If <tt>callbacks//finished_a</tt>\n// does not exist, then <tt>callbacks//discard_b</tt> will be called on\n// each element of +B+ until the end of the sequence is reached (the call\n// will be done with <tt>A[-1]</tt> and <tt>B[jj]</tt> for each element).\n//\n// If +b+ reaches the end of +B+ before +a+ reaches the end of +A+,\n// <tt>callbacks//finished_b</tt> will be called with the current index\n// and element of +A+ (<tt>A[ii]</tt>) and the last index and element of\n// +B+ (<tt>A[-1]</tt>). Again, if <tt>callbacks//finished_b</tt> does not\n// exist on the callback object, then <tt>callbacks//discard_a</tt> will\n// be called on each element of +A+ until the end of the sequence is\n// reached (<tt>A[ii]</tt> and <tt>B[-1]</tt>).\n//\n// There is a chance that one additional <tt>callbacks//discard_a</tt> or\n// <tt>callbacks//discard_b</tt> will be called after the end of the\n// sequence is reached, if +a+ has not yet reached the end of +A+ or +b+\n// has not yet reached the end of +B+.\nDifference.LCS.traverse_sequences = function (seq1, seq2, callbacks, block) {\n  // The block allows callbacks on change events\n  // Ensure that we have at least a default callback object\n  callbacks = callbacks != null ? callbacks : new Difference.LCS.SequenceCallbacks();\n  // Fetch the matches from the __lcs algorithm\n  var matches = Difference.LCS.__lcs(seq1, seq2);\n  var run_finished_a = false,\n    run_finished_b = false;\n  var string = seq1.constructor == String;\n  var a_size = seq1.length,\n    b_size = seq2.length;\n  var ai = 0,\n    bj = 0;\n  var event = null;\n  for (var ii = 0; ii <= matches.length; ii++) {\n    var b_line = matches[ii];\n    var ax = string ? seq1.substr(ii, 1) : seq1[ii];\n    var bx = string ? seq2.substr(bj, bj + 1) : seq2[bj];\n    if (b_line == null) {\n      if (ax != null) {\n        event = new Difference.LCS.ContextChange('-', ii, ax, bj, bx);\n        if (block != null) event = block(event);\n        callbacks.discard_a(event);\n      }\n    } else {\n      while (bj < b_line) {\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        event = new Difference.LCS.ContextChange('+', ii, ax, bj, bx);\n        if (block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;\n      }\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('=', ii, ax, bj, bx);\n      if (block != null) event = block(event);\n      callbacks.match(event);\n      bj = bj + 1;\n    }\n\n    // Update the ai with the current index point\n    ai = ii;\n  }\n\n  // Update pointer\n  ai = ai + 1;\n\n  // The last entry (if any) processed was a match. +ai+ and +bj+ point\n  // just past the last matching lines in their sequences.\n  while (ai < a_size || bj < b_size) {\n    // last A\n    if (ai == a_size && bj < b_size) {\n      if (callbacks.finished_a != null && !run_finished_a) {\n        ax = string ? seq1.substr(seq1.length - 1, 1) : seq1[seq1.length - 1];\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        event = new Difference.LCS.ContextChange('>', a_size - 1, ax, bj, bx);\n        if (block != null) event = block(event);\n        callbacks.finished_a(event);\n        run_finished_a = true;\n      } else {\n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        do {\n          bx = string ? seq2.substr(bj, 1) : seq2[bj];\n          event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n          if (block != null) event = block(event);\n          callbacks.discard_b(event);\n          bj = bj + 1;\n        } while (bj < b_size);\n      }\n    }\n\n    // last B?\n    if (bj == b_size && ai < a_size) {\n      if (callbacks.finished_b != null && !run_finished_b) {\n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        bx = string ? seq2.substr(seq2.length - 1, 1) : seq2[seq2.length - 1];\n        event = new Difference.LCS.ContextChange('<', ai, ax, b_size - 1, bx);\n        if (block != null) event = block(event);\n        callbacks.finished_b(event);\n        run_finished_b = true;\n      } else {\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        do {\n          ax = string ? seq1.substr(ai, 1) : seq1[ai];\n          event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n          if (block != null) event = block(event);\n          callbacks.discard_a(event);\n          ai = ai + 1;\n        } while (bj < b_size);\n      }\n    }\n    if (ai < a_size) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n      if (block != null) event = block(event);\n      callbacks.discard_a(event);\n      ai = ai + 1;\n    }\n    if (bj < b_size) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n      if (block != null) event = block(event);\n      callbacks.discard_b(event);\n      bj = bj + 1;\n    }\n  }\n};\n\n// //traverse_balanced is an alternative to //traverse_sequences. It\n// uses a different algorithm to iterate through the entries in the\n// computed longest common subsequence. Instead of viewing the changes as\n// insertions or deletions from one of the sequences, //traverse_balanced\n// will report <em>changes</em> between the sequences. To represent a\n//\n// The arguments to //traverse_balanced are the two sequences to traverse\n// and a callback object, like this:\n//\n//   traverse_balanced(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)\n//\n// //sdiff is implemented with //traverse_balanced.\n//\n// == Callback Methods\n// Optional callback methods are <em>emphasized</em>.\n//\n// callbacks//match::               Called when +a+ and +b+ are pointing\n//                                 to common elements in +A+ and +B+.\n// callbacks//discard_a::           Called when +a+ is pointing to an\n//                                 element not in +B+.\n// callbacks//discard_b::           Called when +b+ is pointing to an\n//                                 element not in +A+.\n// <em>callbacks//change</em>::     Called when +a+ and +b+ are pointing\n//                                 to the same relative position, but\n//                                 <tt>A[a]</tt> and <tt>B[b]</tt> are\n//                                 not the same; a <em>change</em> has\n//                                 occurred.\n//\n// //traverse_balanced might be a bit slower than //traverse_sequences,\n// noticable only while processing huge amounts of data.\n//\n// The +sdiff+ function of this module is implemented as call to\n// //traverse_balanced.\n//\n// == Algorithm\n//       a---+\n//           v\n//       A = a b c e h j l m n p\n//       B = b c d e f j k l m r s t\n//           ^\n//       b---+\n//\n// === Matches\n// If there are two arrows (+a+ and +b+) pointing to elements of\n// sequences +A+ and +B+, the arrows will initially point to the first\n// elements of their respective sequences. //traverse_sequences will\n// advance the arrows through the sequences one element at a time,\n// calling a method on the user-specified callback object before each\n// advance. It will advance the arrows in such a way that if there are\n// elements <tt>A[ii]</tt> and <tt>B[jj]</tt> which are both equal and\n// part of the longest common subsequence, there will be some moment\n// during the execution of //traverse_sequences when arrow +a+ is pointing\n// to <tt>A[ii]</tt> and arrow +b+ is pointing to <tt>B[jj]</tt>. When\n// this happens, //traverse_sequences will call <tt>callbacks//match</tt>\n// and then it will advance both arrows.\n//\n// === Discards\n// Otherwise, one of the arrows is pointing to an element of its sequence\n// that is not part of the longest common subsequence.\n// //traverse_sequences will advance that arrow and will call\n// <tt>callbacks//discard_a</tt> or <tt>callbacks//discard_b</tt>,\n// depending on which arrow it advanced.\n//\n// === Changes\n// If both +a+ and +b+ point to elements that are not part of the longest\n// common subsequence, then //traverse_sequences will try to call\n// <tt>callbacks//change</tt> and advance both arrows. If\n// <tt>callbacks//change</tt> is not implemented, then\n// <tt>callbacks//discard_a</tt> and <tt>callbacks//discard_b</tt> will be\n// called in turn.\n//\n// The methods for <tt>callbacks//match</tt>, <tt>callbacks//discard_a</tt>,\n// <tt>callbacks//discard_b</tt>, and <tt>callbacks//change</tt> are\n// invoked with an event comprising the action (\"=\", \"+\", \"-\", or \"!\",\n// respectively), the indicies +ii+ and +jj+, and the elements\n// <tt>A[ii]</tt> and <tt>B[jj]</tt>. Return values are discarded by\n// //traverse_balanced.\n//\n// === Context\n// Note that +ii+ and +jj+ may not be the same index position, even if\n// +a+ and +b+ are considered to be pointing to matching or changed\n// elements.\nDifference.LCS.traverse_balanced = function (seq1, seq2, callbacks, block) {\n  // Ensure that we have at least a default callback object\n  callbacks = callbacks != null ? callbacks : new Difference.LCS.BalancedCallbacks();\n  // Fetch the matches from the __lcs algorithm\n  var matches = Difference.LCS.__lcs(seq1, seq2);\n  var a_size = seq1.length;\n  var b_size = seq2.length;\n  var ai = 0,\n    bj = 0;\n  var mb = 0;\n  var ma = -1;\n  var string = seq1.constructor == String;\n  var ax = null,\n    bx = null,\n    event = null;\n  var execute = true;\n\n  // Process all the lines in the match vector.\n  while (true) {\n    // Find next match indices +ma+ and +mb+\n    while (execute) {\n      ma = ma + 1;\n      if (!(ma < matches.length && matches[ma] == null)) break;\n      // execute = !(ma < matches.length && matches[ma] == null);\n    }\n\n    if (ma >= matches.length) break; // end of matches\n    mb = matches[ma];\n\n    // Change seq2\n    while (ai < ma || bj < mb) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n\n      // Calculate result\n      var result = [ai < ma, bj < mb];\n      if (result[0] && result[1]) {\n        if (callbacks.change != null) {\n          event = new Difference.LCS.ContextChange('!', ai, ax, bj, bx);\n          if (block != null) event = block(event);\n          callbacks.change(event);\n          ai = ai + 1;\n          bj = bj + 1;\n        } else {\n          event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n          if (block != null) event = block(event);\n          callbacks.discard_a(event);\n          ai = ai + 1;\n          ax = string ? seq1.substr(ai, 1) : seq1[ai];\n          event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n          if (block != null) event = block(event);\n          callbacks.discard_b(event);\n          bj = bj + 1;\n        }\n      } else if (result[0] && !result[1]) {\n        event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n        if (block != null) event = block(event);\n        callbacks.discard_a(event);\n        ai = ai + 1;\n      } else if (!result[0] && result[1]) {\n        event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n        if (block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;\n      }\n    }\n\n    // Match\n    ax = string ? seq1.substr(ai, 1) : seq1[ai];\n    bx = string ? seq2.substr(bj, 1) : seq2[bj];\n    event = new Difference.LCS.ContextChange('=', ai, ax, bj, bx);\n    if (block != null) event = block(event);\n    callbacks.match(event);\n    ai = ai + 1;\n    bj = bj + 1;\n  }\n  while (ai < a_size || bj < b_size) {\n    ax = string ? seq1.substr(ai, 1) : seq1[ai];\n    bx = string ? seq2.substr(bj, 1) : seq2[bj];\n    var result = [ai < a_size, bj < b_size];\n    if (result[0] && result[1]) {\n      if (callbacks.change != null) {\n        event = new Difference.LCS.ContextChange('!', ai, ax, bj, bx);\n        if (block != null) event = block(event);\n        callbacks.change(event);\n        ai = ai + 1;\n        bj = bj + 1;\n      } else {\n        event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n        if (block != null) event = block(event);\n        callbacks.discard_a(event);\n        ai = ai + 1;\n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n        if (block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;\n      }\n    } else if (result[0] && !result[1]) {\n      event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n      if (block != null) event = block(event);\n      callbacks.discard_a(event);\n      ai = ai + 1;\n    } else if (!result[0] && result[1]) {\n      event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n      if (block != null) event = block(event);\n      callbacks.discard_b(event);\n      bj = bj + 1;\n    }\n  }\n};\n\n// Given two sequenced Enumerables, LCS returns an Array containing their\n// longest common subsequences.\n// \n//   lcs = Diff::LCS.LCS(seq1, seq2)\n// \n// This array whose contents is such that:\n// \n//   lcs.each_with_index do |ee, ii|\n//     assert(ee.nil? || (seq1[ii] == seq2[ee]))\n//   end\n// \n// If a block is provided, the matching subsequences will be yielded from\n// +seq1+ in turn and may be modified before they are placed into the\n// returned Array of subsequences.\nDifference.LCS.LCS = function (seq1, seq2, block) {\n  var matches = Difference.LCS.__lcs(seq1, seq2);\n  var ret = [];\n  for (var ii = 0; ii < matches.length; ii++) {\n    if (matches[ii] != null) {\n      if (block != null) {\n        ret.push(block(seq1[ii]));\n      } else {\n        ret.push(seq1[ii]);\n      }\n    }\n  }\n  // Return the result\n  return ret;\n};\nvar PATCH_MAP = {\n  patch: {\n    '+': '+',\n    '-': '-',\n    '!': '!',\n    '=': '='\n  },\n  unpatch: {\n    '+': '-',\n    '-': '+',\n    '!': '!',\n    '=': '='\n  }\n};\n\n// Given a patchset, convert the current version to the new\n// version. If +direction+ is not specified (must be\n// <tt>:patch</tt> or <tt>:unpatch</tt>), then discovery of the\n// direction of the patch will be attempted.\nDifference.LCS.patch = function (src, patchset, direction) {\n  var string = src.constructor == String;\n  // Start with an empty type of the source's class\n  var res = string ? '' : [];\n\n  // Normalize the patchset\n  var patchset = this.__normalize_patchset(patchset);\n  var direction = direction || Difference.LCS.__diff_direction(src, patchset);\n  direction = direction || \"patch\";\n  var ai = 0,\n    bj = 0;\n  var el = null,\n    op = null,\n    np = null;\n  for (var i = 0; i < patchset.length; i++) {\n    var change = patchset[i];\n    // Both Change and ContextChange has the action\n    var action = PATCH_MAP[direction][change.action];\n    if (change instanceof ContextChange) {\n      if (direction == 'patch') {\n        el = change.new_element;\n        op = change.old_position;\n        np = change.new_position;\n      } else if (direction == 'unpatch') {\n        el = change.old_element;\n        op = change.new_position;\n        np = change.old_position;\n      }\n      if (action == '-') {\n        //Remove details from the old string\n        while (ai < op) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        ai = ai + 1;\n      } else if (action == '+') {\n        while (bj < np) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        string ? res = res + el : res.push(el);\n        bj = bj + 1;\n      } else if (action == '=') {\n        // This only appears in sdiff output with the SDiff callback.\n        // Therefore, we only need to worry about dealing with a single\n        // element.\n        string ? res = res + el : res.push(el);\n        ai = ai + 1;\n        bj = bj + 1;\n      } else if (action == '!') {\n        while (ai < op) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        bj = bj + 1;\n        ai = ai + 1;\n        string ? res = res + el : res.push(el);\n      }\n    } else if (change instanceof Change) {\n      if (action == '-') {\n        while (ai < change.position) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        ai = ai + 1;\n      } else if (action = '+') {\n        while (bj < change.position) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        bj = bj + 1;\n        string ? res = res + change.element : res.push(change.element);\n      }\n    }\n  }\n  while (ai < src.length) {\n    string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n    ai = ai + 1;\n    bj = bj + 1;\n  }\n  return res;\n};\n\n// Examine the patchset and the source to see in which direction the\n// patch should be applied.\n//\n// WARNING: By default, this examines the whole patch, so this could take\n// some time. This also works better with Diff::LCS::ContextChange or\n// Diff::LCS::Change as its source, as an array will cause the creation\n// of one of the above.\nDifference.LCS.__diff_direction = function (src, patchset, limit) {\n  var count = 0,\n    left = 0,\n    left_miss = 0,\n    right = 0,\n    right_miss = 0,\n    element = null;\n  var string = src.constructor == String;\n\n  // Process all changes in the patchset\n  for (var i = 0; i < patchset.length; i++) {\n    var change = patchset[i];\n    count = count + 1;\n    if (change instanceof Change) {\n      // With a simplistic change, we can't tell the difference between\n      // the left and right on '!' actions, so we ignore those. On '='\n      // actions, if there's a miss, we miss both left and right.\n      element = string ? src.substr(change.position, 1) : src[change.position];\n      if (change.action == '-') {\n        element == change.element ? left = left + 1 : left_miss = left_miss + 1;\n      } else if (change.action == '+') {\n        element == change.element ? right = right + 1 : right_miss = right_miss + 1;\n      } else if (change.action == '=') {\n        if (element != change.element) {\n          left_miss = left_miss + 1;\n          right_miss = right_miss + 1;\n        }\n      }\n    } else if (change instanceof ContextChange) {\n      if (change.action == '-') {\n        element = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        element == change.old_element ? left = left + 1 : left_miss = left_miss + 1;\n      } else if (change.action == '+') {\n        element = string ? src.substr(change.new_position, 1) : src[change.new_position];\n        element == change.new_element ? right = right + 1 : right_miss = right_miss + 1;\n      } else if (change.action == '=') {\n        var le = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        var re = string ? src.substr(change.new_position, 1) : src[change.new_position];\n        if (le != change.old_element) left_miss = left_miss + 1;\n        if (re != change.new_element) right_miss = right_miss + 1;\n      } else if (change.action == '!') {\n        element = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        if (element == change.old_element) {\n          left = left + 1;\n        } else {\n          left_miss = left_miss + 1;\n          right_miss = right_miss + 1;\n        }\n      }\n    }\n    if (limit != null && count > limit) break;\n  }\n  ;\n  var no_left = left == 0 && left_miss >= 0;\n  var no_right = right == 0 && right_miss >= 0;\n  var result = [no_left, no_right];\n  if (!no_left && no_right) {\n    return \"patch\";\n  } else if (no_left && !no_right) {\n    return \"unpatch\";\n  } else {\n    throw \"The provided patchset does not appear to apply to the provided value as either source or destination value.\";\n  }\n};\n\n// Normalize the patchset. A patchset is always a sequence of changes, but\n// how those changes are represented may vary, depending on how they were\n// generated. In all cases we support, we also support the array\n// representation of the changes. The formats are:\n//\n//   [ // patchset <- Diff::LCS.diff(a, b)\n//     [ // one or more hunks\n//       Diff::LCS::Change // one or more changes\n//     ] ]\n//\n//   [ // patchset, equivalent to the above\n//     [ // one or more hunks\n//       [ action, line, value ] // one or more changes\n//     ] ]\n//\n//   [ // patchset <- Diff::LCS.diff(a, b, Diff::LCS::ContextDiffCallbacks)\n//     //       OR <- Diff::LCS.sdiff(a, b, Diff::LCS::ContextDiffCallbacks)\n//     [ // one or more hunks\n//       Diff::LCS::ContextChange // one or more changes\n//     ] ]\n//\n//   [ // patchset, equivalent to the above\n//     [ // one or more hunks\n//       [ action, [ old line, old value ], [ new line, new value ] ]\n//         // one or more changes\n//     ] ]\n//\n//   [ // patchset <- Diff::LCS.sdiff(a, b)\n//     //       OR <- Diff::LCS.diff(a, b, Diff::LCS::SDiffCallbacks)\n//     Diff::LCS::ContextChange // one or more changes\n//   ]\n//\n//   [ // patchset, equivalent to the above\n//     [ action, [ old line, old value ], [ new line, new value ] ]\n//       // one or more changes\n//   ]\n//\n// The result of this will be either of the following.\n//\n//   [ // patchset\n//     Diff::LCS::ContextChange // one or more changes\n//   ]\n//\n//   [ // patchset\n//     Diff::LCS::Change // one or more changes\n//   ]\n//\n// If either of the above is provided, it will be returned as such.\n//\nDifference.LCS.__normalize_patchset = function (patchset) {\n  return flatten(patchset.map(function (hunk) {\n    if (hunk instanceof ContextChange || hunk instanceof Change) {\n      return hunk;\n    } else if (Array.isArray(hunk)) {\n      if (!Array.isArray(hunk[0]) && Array.isArray(hunk[1]) && Array.isArray(hunk[2])) {\n        return ContextChange.from_a(hunk);\n      } else {\n        return hunk.map(function (change) {\n          if (change instanceof ContextChange || change instanceof Change) {\n            return change;\n          } else if (Array.isArray(change)) {\n            // change[1] will ONLY be an array in a ContextChange#to_a call.\n            // In Change#to_a, it represents the line (singular).\n            if (Array.isArray(change[1])) {\n              return ContextChange.from_a(change);\n            } else {\n              return Change.from_a(change);\n            }\n          }\n        });\n      }\n    } else {\n      throw \"Cannot normalize the hunk: \" + util.inspect(hunk);\n    }\n  }));\n};\n\n// Gotten from\nvar flatten = function (array) {\n  return array.reduce(function (a, b) {\n    return a.concat(b);\n  }, []);\n};\n\n// Compute the longest common subsequence between the arrays a and b the result\n// being an array whose content is such that they \n// count = 0\n// result.forEach(function(e) {\n//  if(e) a[count] == b[e];\n//  count++; \n// })\nDifference.LCS.__lcs = function (a, b) {\n  var a_start = 0;\n  var b_start = 0;\n  var a_finish = a.length - 1;\n  var b_finish = b.length - 1;\n  var vector = [];\n\n  // Remove common elements at the beginning\n  while (a_start <= a_finish && b_start <= b_finish && a[a_start] == b[b_start]) {\n    vector[a_start] = b_start;\n    a_start = a_start + 1;\n    b_start = b_start + 1;\n  }\n\n  // Remove common elements at the end\n  while (a_start <= a_finish && b_start <= b_finish && a[a_finish] == b[b_finish]) {\n    vector[a_finish] = b_finish;\n    a_finish = a_finish - 1;\n    b_finish = b_finish - 1;\n  }\n\n  // Now compute the equivalent classes of positions of elements\n  var b_matches = Difference.LCS.__position_hash(b, b_start, b_finish);\n\n  // Define treshold and links\n  var thresh = [];\n  var links = [];\n  for (var ii = a_start; ii <= a_finish; ii++) {\n    var ai = Array.isArray(a) ? a[ii] : a.charAt(ii);\n    var bm = b_matches[ai];\n    bm = bm ? bm : [];\n    var kk = null;\n    bm.reverse().forEach(function (jj) {\n      if (kk != null && thresh[kk] > jj && thresh[kk - 1] < jj) {\n        thresh[kk] = jj;\n      } else {\n        kk = Difference.LCS.__replace_next_larger(thresh, jj, kk);\n      }\n      // Add link\n      if (kk != null) links[kk] = [kk > 0 ? links[kk - 1] : null, ii, jj];\n    });\n  }\n\n  // Build the vector\n  if (thresh.length > 0) {\n    var link = links[thresh.length - 1];\n    while (link != null) {\n      vector[link[1]] = link[2];\n      link = link[0];\n    }\n  }\n\n  // Return the vector of the longest commong subsequence\n  return vector;\n};\n\n// Find the place at which +value+ would normally be inserted into the\n// Enumerable. If that place is already occupied by +value+, do nothing\n// and return +nil+. If the place does not exist (i.e., it is off the end\n// of the Enumerable), add it to the end. Otherwise, replace the element\n// at that point with +value+. It is assumed that the Enumerable's values\n// are numeric.\n//\n// This operation preserves the sort order.\nDifference.LCS.__replace_next_larger = function (enumerable, value, last_index) {\n  // Is it off the end\n  if (enumerable.length == 0 || value > enumerable[enumerable.length - 1]) {\n    enumerable.push(value);\n    return enumerable.length - 1;\n  }\n\n  // Binary search for the insertion point\n  var last_index = last_index || enumerable.length;\n  var first_index = 0;\n  while (first_index <= last_index) {\n    var ii = first_index + last_index >> 1;\n    var found = enumerable[ii];\n    if (value == found) {\n      return null;\n    } else if (value > found) {\n      first_index = ii + 1;\n    } else {\n      last_index = ii - 1;\n    }\n  }\n\n  // The insertion point is in first_index; overwrite the next larger\n  // value.\n  enumerable[first_index] = value;\n  return first_index;\n};\nDifference.LCS.__position_hash = function (enumerable, interval_start, interval_end) {\n  interval_start = interval_start ? interval_start : 0;\n  interval_end = interval_end ? interval_end : -1;\n  var hash = {};\n  for (var i = interval_start; i <= interval_end; i++) {\n    var kk = Array.isArray(enumerable) ? enumerable[i] : enumerable.charAt(i);\n    hash[kk] = Array.isArray(hash[kk]) ? hash[kk] : [];\n    hash[kk].push(i);\n  }\n  return hash;\n};","map":{"version":3,"names":["util","require","SequenceCallbacks","ContextChange","Change","DiffCallbacks","SDiffCallbacks","BalancedCallbacks","ContextDiffCallbacks","Hunk","Difference","exports","LCS","sdiff","seq1","seq2","callbacks","block","Object","prototype","toString","call","traverse_balanced","finish","res","diffs","map","hunk","Array","isArray","v","diff","traverse_sequences","matches","__lcs","run_finished_a","run_finished_b","string","constructor","String","a_size","length","b_size","ai","bj","event","ii","b_line","ax","substr","bx","discard_a","discard_b","match","finished_a","finished_b","mb","ma","execute","result","change","ret","push","PATCH_MAP","patch","unpatch","src","patchset","direction","__normalize_patchset","__diff_direction","el","op","np","i","action","new_element","old_position","new_position","old_element","position","element","limit","count","left","left_miss","right","right_miss","le","re","no_left","no_right","flatten","from_a","inspect","array","reduce","a","b","concat","a_start","b_start","a_finish","b_finish","vector","b_matches","__position_hash","thresh","links","charAt","bm","kk","reverse","forEach","jj","__replace_next_larger","link","enumerable","value","last_index","first_index","found","interval_start","interval_end","hash"],"sources":["/Users/bobbyrein/react-course/golden-brown/node_modules/git/lib/diff/diff.js"],"sourcesContent":["var util = require('util'),\n  SequenceCallbacks = require('./callbacks').SequenceCallbacks,\n  ContextChange = require('./change').ContextChange,\n  Change = require('./change').Change,\n  DiffCallbacks = require('./callbacks').DiffCallbacks,\n  SDiffCallbacks = require('./callbacks').SDiffCallbacks,\n  BalancedCallbacks = require('./callbacks').BalancedCallbacks,\n  ContextDiffCallbacks = require('./callbacks').ContextDiffCallbacks,\n  Hunk = require('./hunk').Hunk;\n\nvar Difference = exports.Difference = function() {  \n}\n\nDifference.LCS = function() {  \n}\n\n// Scope the Sequence Callbacks class\nDifference.LCS.SequenceCallbacks = SequenceCallbacks;\nDifference.LCS.ContextChange = ContextChange;\nDifference.LCS.DiffCallbacks = DiffCallbacks;\nDifference.LCS.SDiffCallbacks = SDiffCallbacks;\nDifference.LCS.BalancedCallbacks = BalancedCallbacks;\nDifference.LCS.ContextDiffCallbacks = ContextDiffCallbacks;\nDifference.LCS.Change = Change;\nDifference.LCS.Hunk = Hunk;\n\n// Diff::LCS.sdiff computes all necessary components to show two sequences\n// and their minimized differences side by side, just like the Unix\n// utility <em>sdiff</em> does:\n//\n//     old        <     -\n//     same             same\n//     before     |     after\n//     -          >     new\n//\n// See Diff::LCS::SDiffCallbacks for the default behaviour. An alternate\n// behaviour may be implemented with Diff::LCS::ContextDiffCallbacks. If\n// a Class argument is provided for +callbacks+, //diff will attempt to\n// initialise it. If the +callbacks+ object (possibly initialised)\n// responds to //finish, it will be called.\nDifference.LCS.sdiff = function(seq1, seq2, callbacks, block) {\n  callbacks = callbacks != null ? callbacks : Difference.LCS.SDiffCallbacks;\n  \n  if(Object.prototype.toString.call(callbacks) == \"[object Function]\") {\n    callbacks = new callbacks();\n  }\n  \n  // Traverse the sequence\n  Difference.LCS.traverse_balanced(seq1, seq2, callbacks);  \n  if(callbacks.finish != null) callbacks.finish();\n  \n  if(block != null) {    \n    var res = callbacks.diffs.map(function(hunk) {\n      if(Array.isArray(hunk)) {\n        hunk = hunk.map(function(v) { return block(v); });\n      } else {\n        block(hunk);\n      }\n    });\n    \n    return res;\n  } else {    \n    return callbacks.diffs;\n  }  \n}\n\n// Diff::LCS.diff computes the smallest set of additions and deletions\n// necessary to turn the first sequence into the second, and returns a\n// description of these changes.\n// \n// See Diff::LCS::DiffCallbacks for the default behaviour. An alternate\n// behaviour may be implemented with Diff::LCS::ContextDiffCallbacks.\n// If a Class argument is provided for +callbacks+, //diff will attempt\n// to initialise it. If the +callbacks+ object (possibly initialised)\n// responds to //finish, it will be called.\nDifference.LCS.diff = function(seq1, seq2, callbacks, block) {\n  callbacks = callbacks != null ? callbacks : Difference.LCS.DiffCallbacks;\n  \n  if(Object.prototype.toString.call(callbacks) == \"[object Function]\") {\n    callbacks = new callbacks();\n  }\n  \n  // Traverse the sequence\n  Difference.LCS.traverse_sequences(seq1, seq2, callbacks);  \n  if(callbacks.finish != null) callbacks.finish();\n  \n  if(block != null) {    \n    var res = callbacks.diffs.map(function(hunk) {\n      if(Array.isArray(hunk)) {\n        hunk = hunk.map(function(v) { return block(v); });\n      } else {\n        block(hunk);\n      }\n    });\n    \n    return res;\n  } else {    \n    return callbacks.diffs;\n  }\n}\n\n\n// Diff::LCS.traverse_sequences is the most general facility provided by this\n// module; +diff+ and +LCS+ are implemented as calls to it.\n//\n// The arguments to //traverse_sequences are the two sequences to\n// traverse, and a callback object, like this:\n//\n//   traverse_sequences(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)\n//\n// //diff is implemented with //traverse_sequences.\n//\n// == Callback Methods\n// Optional callback methods are <em>emphasized</em>.\n//\n// callbacks//match::               Called when +a+ and +b+ are pointing\n//                                 to common elements in +A+ and +B+.\n// callbacks//discard_a::           Called when +a+ is pointing to an\n//                                 element not in +B+.\n// callbacks//discard_b::           Called when +b+ is pointing to an\n//                                 element not in +A+.\n// <em>callbacks//finished_a</em>:: Called when +a+ has reached the end of\n//                                 sequence +A+.\n// <em>callbacks//finished_b</em>:: Called when +b+ has reached the end of\n//                                 sequence +B+.\n//\n// == Algorithm\n//       a---+\n//           v\n//       A = a b c e h j l m n p\n//       B = b c d e f j k l m r s t\n//           ^\n//       b---+\n//\n// If there are two arrows (+a+ and +b+) pointing to elements of\n// sequences +A+ and +B+, the arrows will initially point to the first\n// elements of their respective sequences. //traverse_sequences will\n// advance the arrows through the sequences one element at a time,\n// calling a method on the user-specified callback object before each\n// advance. It will advance the arrows in such a way that if there are\n// elements <tt>A[ii]</tt> and <tt>B[jj]</tt> which are both equal and\n// part of the longest common subsequence, there will be some moment\n// during the execution of //traverse_sequences when arrow +a+ is pointing\n// to <tt>A[ii]</tt> and arrow +b+ is pointing to <tt>B[jj]</tt>. When\n// this happens, //traverse_sequences will call <tt>callbacks//match</tt>\n// and then it will advance both arrows.\n//\n// Otherwise, one of the arrows is pointing to an element of its sequence\n// that is not part of the longest common subsequence.\n// //traverse_sequences will advance that arrow and will call\n// <tt>callbacks//discard_a</tt> or <tt>callbacks//discard_b</tt>, depending\n// on which arrow it advanced. If both arrows point to elements that are\n// not part of the longest common subsequence, then //traverse_sequences\n// will advance one of them and call the appropriate callback, but it is\n// not specified which it will call.\n//\n// The methods for <tt>callbacks//match</tt>, <tt>callbacks//discard_a</tt>,\n// and <tt>callbacks//discard_b</tt> are invoked with an event comprising\n// the action (\"=\", \"+\", or \"-\", respectively), the indicies +ii+ and\n// +jj+, and the elements <tt>A[ii]</tt> and <tt>B[jj]</tt>. Return\n// values are discarded by //traverse_sequences.\n//\n// === End of Sequences\n// If arrow +a+ reaches the end of its sequence before arrow +b+ does,\n// //traverse_sequence try to call <tt>callbacks//finished_a</tt> with the\n// last index and element of +A+ (<tt>A[-1]</tt>) and the current index\n// and element of +B+ (<tt>B[jj]</tt>). If <tt>callbacks//finished_a</tt>\n// does not exist, then <tt>callbacks//discard_b</tt> will be called on\n// each element of +B+ until the end of the sequence is reached (the call\n// will be done with <tt>A[-1]</tt> and <tt>B[jj]</tt> for each element).\n//\n// If +b+ reaches the end of +B+ before +a+ reaches the end of +A+,\n// <tt>callbacks//finished_b</tt> will be called with the current index\n// and element of +A+ (<tt>A[ii]</tt>) and the last index and element of\n// +B+ (<tt>A[-1]</tt>). Again, if <tt>callbacks//finished_b</tt> does not\n// exist on the callback object, then <tt>callbacks//discard_a</tt> will\n// be called on each element of +A+ until the end of the sequence is\n// reached (<tt>A[ii]</tt> and <tt>B[-1]</tt>).\n//\n// There is a chance that one additional <tt>callbacks//discard_a</tt> or\n// <tt>callbacks//discard_b</tt> will be called after the end of the\n// sequence is reached, if +a+ has not yet reached the end of +A+ or +b+\n// has not yet reached the end of +B+.\nDifference.LCS.traverse_sequences = function(seq1, seq2, callbacks, block) { // The block allows callbacks on change events\n  // Ensure that we have at least a default callback object\n  callbacks = callbacks != null ? callbacks : new Difference.LCS.SequenceCallbacks();\n  // Fetch the matches from the __lcs algorithm\n  var matches = Difference.LCS.__lcs(seq1, seq2);\n  \n  var run_finished_a = false, run_finished_b = false;\n  var string = seq1.constructor == String;\n  \n  var a_size = seq1.length, b_size = seq2.length;\n  var ai = 0, bj = 0;\n  var event = null;\n  \n  for(var ii = 0; ii <= matches.length; ii++) {\n    var b_line = matches[ii];\n    \n    var ax = string ? seq1.substr(ii, 1) : seq1[ii];\n    var bx = string ? seq2.substr(bj, bj + 1) : seq2[bj];\n\n    if(b_line == null) {\n      if(ax != null) {\n        event = new Difference.LCS.ContextChange('-', ii, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_a(event);\n      }\n    } else {\n      while(bj < b_line) {\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        event = new Difference.LCS.ContextChange('+', ii, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;\n      }\n      \n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('=', ii, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.match(event);\n      bj = bj + 1;\n    }\n    \n    // Update the ai with the current index point\n    ai = ii;    \n  }\n  \n  // Update pointer\n  ai = ai + 1;\n  \n  // The last entry (if any) processed was a match. +ai+ and +bj+ point\n  // just past the last matching lines in their sequences.\n  while(ai < a_size || bj < b_size) {\n    // last A\n    if(ai == a_size && bj < b_size) {\n      if(callbacks.finished_a != null && !run_finished_a) {\n        ax = string ? seq1.substr(seq1.length - 1, 1) : seq1[seq1.length - 1];\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        event = new Difference.LCS.ContextChange('>', (a_size - 1), ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.finished_a(event);\n        run_finished_a = true;\n      } else {        \n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        do {\n          bx = string ? seq2.substr(bj, 1) : seq2[bj];\n          event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.discard_b(event);\n          bj = bj + 1;          \n        } while(bj < b_size)\n      }\n    }\n    \n    // last B?\n    if(bj == b_size && ai < a_size) {\n      if(callbacks.finished_b != null && !run_finished_b) {\n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        bx = string ? seq2.substr(seq2.length - 1, 1) : seq2[seq2.length - 1];\n        event = new Difference.LCS.ContextChange('<', ai, ax, (b_size -1), bx);\n        if(block != null) event = block(event);\n        callbacks.finished_b(event);\n        run_finished_b = true;\n      } else {\n        bx = string ? seq2.substr(bj, 1) : seq2[bj];\n        do {\n          ax = string ? seq1.substr(ai, 1) : seq1[ai];\n          event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.discard_a(event);\n          ai = ai + 1;        \n        } while(bj < b_size)\n      }\n    }    \n    \n    if(ai < a_size) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.discard_a(event);\n      ai = ai + 1;\n    }\n\n    if(bj < b_size) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.discard_b(event);\n      bj = bj + 1;\n    }      \n  }  \n}\n\n// //traverse_balanced is an alternative to //traverse_sequences. It\n// uses a different algorithm to iterate through the entries in the\n// computed longest common subsequence. Instead of viewing the changes as\n// insertions or deletions from one of the sequences, //traverse_balanced\n// will report <em>changes</em> between the sequences. To represent a\n//\n// The arguments to //traverse_balanced are the two sequences to traverse\n// and a callback object, like this:\n//\n//   traverse_balanced(seq1, seq2, Diff::LCS::ContextDiffCallbacks.new)\n//\n// //sdiff is implemented with //traverse_balanced.\n//\n// == Callback Methods\n// Optional callback methods are <em>emphasized</em>.\n//\n// callbacks//match::               Called when +a+ and +b+ are pointing\n//                                 to common elements in +A+ and +B+.\n// callbacks//discard_a::           Called when +a+ is pointing to an\n//                                 element not in +B+.\n// callbacks//discard_b::           Called when +b+ is pointing to an\n//                                 element not in +A+.\n// <em>callbacks//change</em>::     Called when +a+ and +b+ are pointing\n//                                 to the same relative position, but\n//                                 <tt>A[a]</tt> and <tt>B[b]</tt> are\n//                                 not the same; a <em>change</em> has\n//                                 occurred.\n//\n// //traverse_balanced might be a bit slower than //traverse_sequences,\n// noticable only while processing huge amounts of data.\n//\n// The +sdiff+ function of this module is implemented as call to\n// //traverse_balanced.\n//\n// == Algorithm\n//       a---+\n//           v\n//       A = a b c e h j l m n p\n//       B = b c d e f j k l m r s t\n//           ^\n//       b---+\n//\n// === Matches\n// If there are two arrows (+a+ and +b+) pointing to elements of\n// sequences +A+ and +B+, the arrows will initially point to the first\n// elements of their respective sequences. //traverse_sequences will\n// advance the arrows through the sequences one element at a time,\n// calling a method on the user-specified callback object before each\n// advance. It will advance the arrows in such a way that if there are\n// elements <tt>A[ii]</tt> and <tt>B[jj]</tt> which are both equal and\n// part of the longest common subsequence, there will be some moment\n// during the execution of //traverse_sequences when arrow +a+ is pointing\n// to <tt>A[ii]</tt> and arrow +b+ is pointing to <tt>B[jj]</tt>. When\n// this happens, //traverse_sequences will call <tt>callbacks//match</tt>\n// and then it will advance both arrows.\n//\n// === Discards\n// Otherwise, one of the arrows is pointing to an element of its sequence\n// that is not part of the longest common subsequence.\n// //traverse_sequences will advance that arrow and will call\n// <tt>callbacks//discard_a</tt> or <tt>callbacks//discard_b</tt>,\n// depending on which arrow it advanced.\n//\n// === Changes\n// If both +a+ and +b+ point to elements that are not part of the longest\n// common subsequence, then //traverse_sequences will try to call\n// <tt>callbacks//change</tt> and advance both arrows. If\n// <tt>callbacks//change</tt> is not implemented, then\n// <tt>callbacks//discard_a</tt> and <tt>callbacks//discard_b</tt> will be\n// called in turn.\n//\n// The methods for <tt>callbacks//match</tt>, <tt>callbacks//discard_a</tt>,\n// <tt>callbacks//discard_b</tt>, and <tt>callbacks//change</tt> are\n// invoked with an event comprising the action (\"=\", \"+\", \"-\", or \"!\",\n// respectively), the indicies +ii+ and +jj+, and the elements\n// <tt>A[ii]</tt> and <tt>B[jj]</tt>. Return values are discarded by\n// //traverse_balanced.\n//\n// === Context\n// Note that +ii+ and +jj+ may not be the same index position, even if\n// +a+ and +b+ are considered to be pointing to matching or changed\n// elements.\nDifference.LCS.traverse_balanced = function(seq1, seq2, callbacks, block) {\n  // Ensure that we have at least a default callback object\n  callbacks = callbacks != null ? callbacks : new Difference.LCS.BalancedCallbacks();\n  // Fetch the matches from the __lcs algorithm\n  var matches = Difference.LCS.__lcs(seq1, seq2);  \n  var a_size = seq1.length;\n  var b_size = seq2.length;\n  var ai = 0, bj = 0;\n  var mb = 0;\n  var ma = -1;\n  var string = seq1.constructor == String;\n  var ax = null, bx = null, event = null;\n  var execute = true;\n\n  // Process all the lines in the match vector.\n  while(true) {\n    // Find next match indices +ma+ and +mb+\n    while(execute) {\n      ma = ma + 1;\n      if(!(ma < matches.length && matches[ma] == null)) break;\n      // execute = !(ma < matches.length && matches[ma] == null);\n    }\n\n    if(ma >= matches.length) break; // end of matches\n    mb = matches[ma];\n\n    // Change seq2\n    while((ai < ma) || (bj < mb)) {\n      ax = string ? seq1.substr(ai, 1) : seq1[ai];\n      bx = string ? seq2.substr(bj, 1) : seq2[bj];\n      \n      // Calculate result\n      var result = [(ai < ma), (bj < mb)];\n      \n      if(result[0] && result[1]) {\n        if(callbacks.change != null) {\n          event = new Difference.LCS.ContextChange('!', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.change(event);\n          ai = ai + 1;\n          bj = bj + 1;\n        } else {\n          event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.discard_a(event);\n          ai = ai + 1;\n          ax = string ? seq1.substr(ai, 1) : seq1[ai];\n          event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n          if(block != null) event = block(event);\n          callbacks.discard_b(event);\n          bj = bj + 1\n        }\n      } else if(result[0] && !result[1]) {\n        event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_a(event);\n        ai = ai + 1;\n      } else if(!result[0] && result[1]) {\n        event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;\n      }      \n    }\n    \n    // Match\n    ax = string ? seq1.substr(ai, 1) : seq1[ai];\n    bx = string ? seq2.substr(bj, 1) : seq2[bj];\n    event = new Difference.LCS.ContextChange('=', ai, ax, bj, bx);\n    if(block != null) event = block(event);\n    callbacks.match(event);\n    ai = ai + 1;\n    bj = bj + 1;    \n  }\n  \n  while((ai < a_size) || (bj < b_size)) {\n    ax = string ? seq1.substr(ai, 1) : seq1[ai];\n    bx = string ? seq2.substr(bj, 1) : seq2[bj];\n    \n    var result = [(ai < a_size), (bj < b_size)];\n    if(result[0] && result[1]) {\n      if(callbacks.change != null) {\n        event = new Difference.LCS.ContextChange('!', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.change(event);\n        ai = ai + 1;\n        bj = bj + 1;\n      } else {\n        event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_a(event);\n        ai = ai + 1;\n        ax = string ? seq1.substr(ai, 1) : seq1[ai];\n        event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n        if(block != null) event = block(event);\n        callbacks.discard_b(event);\n        bj = bj + 1;        \n      }\n    } else if(result[0] && !result[1]) {\n      event = new Difference.LCS.ContextChange('-', ai, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.discard_a(event);\n      ai = ai + 1;\n    } else if(!result[0] && result[1]) {\n      event = new Difference.LCS.ContextChange('+', ai, ax, bj, bx);\n      if(block != null) event = block(event);\n      callbacks.discard_b(event);\n      bj = bj + 1;\n    }\n  }\n}\n\n// Given two sequenced Enumerables, LCS returns an Array containing their\n// longest common subsequences.\n// \n//   lcs = Diff::LCS.LCS(seq1, seq2)\n// \n// This array whose contents is such that:\n// \n//   lcs.each_with_index do |ee, ii|\n//     assert(ee.nil? || (seq1[ii] == seq2[ee]))\n//   end\n// \n// If a block is provided, the matching subsequences will be yielded from\n// +seq1+ in turn and may be modified before they are placed into the\n// returned Array of subsequences.\nDifference.LCS.LCS = function(seq1, seq2, block) {\n  var matches = Difference.LCS.__lcs(seq1, seq2);\n  var ret = [];\n  \n  for(var ii = 0; ii < matches.length; ii++) {\n    if(matches[ii] != null) {\n      if(block != null) {\n        ret.push(block(seq1[ii]));\n      } else {\n        ret.push(seq1[ii]);\n      }\n    }\n  }\n  // Return the result\n  return ret;\n}\n\nvar PATCH_MAP = {\n  patch:{ '+':'+', '-':'-', '!':'!', '=':'=' },\n  unpatch:{ '+':'-', '-':'+', '!':'!', '=':'=' }\n}\n\n// Given a patchset, convert the current version to the new\n// version. If +direction+ is not specified (must be\n// <tt>:patch</tt> or <tt>:unpatch</tt>), then discovery of the\n// direction of the patch will be attempted.\nDifference.LCS.patch = function(src, patchset, direction) {\n  var string = src.constructor == String;\n  // Start with an empty type of the source's class\n  var res = string ? '' : [];\n  \n  // Normalize the patchset\n  var patchset = this.__normalize_patchset(patchset);\n  var direction = direction || Difference.LCS.__diff_direction(src, patchset);\n  direction = direction || \"patch\";\n  \n  var ai = 0, bj = 0;\n  var el = null, op = null, np = null;\n  \n  for(var i = 0; i < patchset.length; i++) {\n    var change = patchset[i];\n    // Both Change and ContextChange has the action\n    var action = PATCH_MAP[direction][change.action];\n    \n    if(change instanceof ContextChange) {\n      if(direction == 'patch') {\n        el = change.new_element;\n        op = change.old_position;\n        np = change.new_position;\n      } else if(direction == 'unpatch') {\n        el = change.old_element;\n        op = change.new_position;\n        np = change.old_position;\n      }\n      \n      if(action == '-') { //Remove details from the old string\n        while(ai < op) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }        \n        ai = ai + 1;\n      } else if(action == '+') {\n        while(bj < np) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        string ? res = res + el : res.push(el);\n        bj = bj + 1;\n      } else if(action == '=') {\n        // This only appears in sdiff output with the SDiff callback.\n        // Therefore, we only need to worry about dealing with a single\n        // element.\n        string ? res = res + el : res.push(el);\n        ai = ai + 1;\n        bj = bj + 1;\n      } else if(action == '!') {\n        while(ai < op) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        bj = bj + 1;\n        ai = ai + 1;\n        string ? res = res + el : res.push(el);\n      }\n    } else if(change instanceof Change) {\n      if(action == '-') {\n        while(ai < change.position) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        ai = ai + 1;\n      } else if(action = '+') {\n        while(bj < change.position) {\n          string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n          ai = ai + 1;\n          bj = bj + 1;\n        }\n        bj = bj + 1;\n        string ? res = res + change.element : res.push(change.element);\n      }\n    }    \n  }  \n  \n  while(ai < src.length) {\n    string ? res = res + src.substr(ai, 1) : res.push(src[ai]);\n    ai = ai + 1;\n    bj = bj + 1;\n  }\n  \n  return res;  \n}\n\n// Examine the patchset and the source to see in which direction the\n// patch should be applied.\n//\n// WARNING: By default, this examines the whole patch, so this could take\n// some time. This also works better with Diff::LCS::ContextChange or\n// Diff::LCS::Change as its source, as an array will cause the creation\n// of one of the above.\nDifference.LCS.__diff_direction = function(src, patchset, limit) {\n  var count = 0, left = 0, left_miss = 0, right = 0, right_miss = 0, element = null;\n  var string = src.constructor == String;\n\n  // Process all changes in the patchset\n  for(var i = 0; i < patchset.length; i++) {\n    var change = patchset[i];\n    count = count + 1;\n    \n    if(change instanceof Change) {\n      // With a simplistic change, we can't tell the difference between\n      // the left and right on '!' actions, so we ignore those. On '='\n      // actions, if there's a miss, we miss both left and right.\n      element = string ? src.substr(change.position, 1) : src[change.position];\n      \n      if(change.action == '-') {\n        element == change.element ? left = left + 1 : left_miss = left_miss + 1;\n      } else if(change.action == '+') {\n        element == change.element ? right = right + 1 : right_miss = right_miss + 1;\n      } else if(change.action == '=') {\n        if(element != change.element) {\n          left_miss = left_miss + 1;\n          right_miss = right_miss + 1;\n        }\n      }      \n    } else if(change instanceof ContextChange) {\n      if(change.action == '-') {\n        element = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        element == change.old_element ? left = left + 1 : left_miss = left_miss + 1;        \n      } else if(change.action == '+') {\n        element = string ? src.substr(change.new_position, 1) : src[change.new_position];\n        element == change.new_element ? right = right + 1 : right_miss = right_miss + 1;\n      } else if(change.action == '=') {\n        var le = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        var re = string ? src.substr(change.new_position, 1) : src[change.new_position];\n        \n        if(le != change.old_element) left_miss = left_miss + 1;\n        if(re != change.new_element) right_miss = right_miss + 1;\n      } else if(change.action == '!') {\n        element = string ? src.substr(change.old_position, 1) : src[change.old_position];\n        if(element == change.old_element) {\n          left = left + 1;\n        } else {\n          left_miss = left_miss + 1;\n          right_miss = right_miss + 1;\n        }\n      }\n    }\n    \n    if(limit != null && count > limit) break;\n  };\n  \n  var no_left = (left == 0) && (left_miss >= 0);\n  var no_right = (right == 0) && (right_miss >= 0);\n  \n  var result = [no_left, no_right];\n  if(!no_left && no_right) {\n    return \"patch\";\n  } else if(no_left && !no_right) {\n    return \"unpatch\";\n  } else {\n    throw \"The provided patchset does not appear to apply to the provided value as either source or destination value.\"\n  }\n}\n\n// Normalize the patchset. A patchset is always a sequence of changes, but\n// how those changes are represented may vary, depending on how they were\n// generated. In all cases we support, we also support the array\n// representation of the changes. The formats are:\n//\n//   [ // patchset <- Diff::LCS.diff(a, b)\n//     [ // one or more hunks\n//       Diff::LCS::Change // one or more changes\n//     ] ]\n//\n//   [ // patchset, equivalent to the above\n//     [ // one or more hunks\n//       [ action, line, value ] // one or more changes\n//     ] ]\n//\n//   [ // patchset <- Diff::LCS.diff(a, b, Diff::LCS::ContextDiffCallbacks)\n//     //       OR <- Diff::LCS.sdiff(a, b, Diff::LCS::ContextDiffCallbacks)\n//     [ // one or more hunks\n//       Diff::LCS::ContextChange // one or more changes\n//     ] ]\n//\n//   [ // patchset, equivalent to the above\n//     [ // one or more hunks\n//       [ action, [ old line, old value ], [ new line, new value ] ]\n//         // one or more changes\n//     ] ]\n//\n//   [ // patchset <- Diff::LCS.sdiff(a, b)\n//     //       OR <- Diff::LCS.diff(a, b, Diff::LCS::SDiffCallbacks)\n//     Diff::LCS::ContextChange // one or more changes\n//   ]\n//\n//   [ // patchset, equivalent to the above\n//     [ action, [ old line, old value ], [ new line, new value ] ]\n//       // one or more changes\n//   ]\n//\n// The result of this will be either of the following.\n//\n//   [ // patchset\n//     Diff::LCS::ContextChange // one or more changes\n//   ]\n//\n//   [ // patchset\n//     Diff::LCS::Change // one or more changes\n//   ]\n//\n// If either of the above is provided, it will be returned as such.\n//\nDifference.LCS.__normalize_patchset = function(patchset) {\n  return flatten(patchset.map(function(hunk) {\n    if(hunk instanceof ContextChange || hunk instanceof Change) {\n      return hunk;\n    } else if(Array.isArray(hunk)) {\n      if(!Array.isArray(hunk[0]) && Array.isArray(hunk[1]) && Array.isArray(hunk[2])) {\n        return ContextChange.from_a(hunk);\n      } else {\n        return hunk.map(function(change) {\n          if(change instanceof ContextChange || change instanceof Change) {\n            return change;\n          } else if(Array.isArray(change)) {\n            // change[1] will ONLY be an array in a ContextChange#to_a call.\n            // In Change#to_a, it represents the line (singular).\n            if(Array.isArray(change[1])) {\n              return ContextChange.from_a(change);\n            } else {\n              return Change.from_a(change);\n            }\n          }\n        });\n      }      \n    } else {\n      throw \"Cannot normalize the hunk: \" + util.inspect(hunk);\n    }    \n  }));\n}\n\n// Gotten from\nvar flatten = function(array) {\n  return array.reduce(function(a,b) {  \n    return a.concat(b);  \n  }, []);\n}\n\n// Compute the longest common subsequence between the arrays a and b the result\n// being an array whose content is such that they \n// count = 0\n// result.forEach(function(e) {\n//  if(e) a[count] == b[e];\n//  count++; \n// })\nDifference.LCS.__lcs = function(a, b) {\n  var a_start = 0;\n  var b_start = 0;\n  var a_finish = a.length - 1;\n  var b_finish = b.length - 1;\n  var vector = [];\n    \n  // Remove common elements at the beginning\n  while((a_start <= a_finish) && (b_start <= b_finish) && (a[a_start] == b[b_start])) {\n    vector[a_start] = b_start;\n    a_start = a_start + 1;\n    b_start = b_start + 1;\n  }\n  \n  // Remove common elements at the end\n  while((a_start <= a_finish) && (b_start <= b_finish) && (a[a_finish] == b[b_finish])) {\n    vector[a_finish] = b_finish;\n    a_finish = a_finish - 1;\n    b_finish = b_finish - 1;\n  }\n  \n  // Now compute the equivalent classes of positions of elements\n  var b_matches = Difference.LCS.__position_hash(b, b_start, b_finish);\n  \n  // Define treshold and links\n  var thresh = [];\n  var links = [];\n  \n  for(var ii = a_start; ii <= a_finish; ii++) {\n    var ai = Array.isArray(a) ? a[ii] : a.charAt(ii);\n    var bm = b_matches[ai];\n    bm = bm ? bm : [];\n    var kk = null;\n    \n    bm.reverse().forEach(function(jj) {\n      if(kk != null && (thresh[kk] > jj) && (thresh[kk - 1] < jj)) {\n        thresh[kk] = jj;\n      } else {\n        kk = Difference.LCS.__replace_next_larger(thresh, jj, kk);\n      }\n      // Add link\n      if(kk != null) links[kk] = [(kk > 0) ? links[kk - 1] : null, ii, jj];\n    });\n  }\n    \n  // Build the vector\n  if(thresh.length > 0) {\n    var link = links[thresh.length - 1];\n    \n    while(link != null) {\n      vector[link[1]] = link[2];\n      link = link[0];\n    }\n  }\n  \n  // Return the vector of the longest commong subsequence\n  return vector;\n}\n\n// Find the place at which +value+ would normally be inserted into the\n// Enumerable. If that place is already occupied by +value+, do nothing\n// and return +nil+. If the place does not exist (i.e., it is off the end\n// of the Enumerable), add it to the end. Otherwise, replace the element\n// at that point with +value+. It is assumed that the Enumerable's values\n// are numeric.\n//\n// This operation preserves the sort order.\nDifference.LCS.__replace_next_larger = function(enumerable, value, last_index) {\n  // Is it off the end\n  if(enumerable.length == 0 || (value > enumerable[enumerable.length - 1])) {\n    enumerable.push(value);\n    return enumerable.length - 1;\n  }\n  \n  // Binary search for the insertion point\n  var last_index = last_index || enumerable.length;\n  var first_index = 0;\n  \n  while(first_index <= last_index) {\n    var ii = (first_index + last_index) >> 1;\n    var found = enumerable[ii];\n    \n    if(value == found) {\n      return null;\n    } else if(value > found) {\n      first_index = ii + 1;\n    } else {\n      last_index = ii - 1;\n    }\n  }\n  \n  // The insertion point is in first_index; overwrite the next larger\n  // value.\n  enumerable[first_index] = value;\n  return first_index;\n}\n\nDifference.LCS.__position_hash = function(enumerable, interval_start, interval_end) {\n  interval_start = interval_start ? interval_start : 0;\n  interval_end = interval_end ? interval_end : -1;\n  \n  var hash = {}\n  for(var i = interval_start; i <= interval_end; i++) {\n    var kk = Array.isArray(enumerable) ? enumerable[i] : enumerable.charAt(i);\n    hash[kk] = Array.isArray(hash[kk]) ? hash[kk] : [];\n    hash[kk].push(i);\n  }\n  return hash;\n}"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;EACxBC,iBAAiB,GAAGD,OAAO,CAAC,aAAa,CAAC,CAACC,iBAAiB;EAC5DC,aAAa,GAAGF,OAAO,CAAC,UAAU,CAAC,CAACE,aAAa;EACjDC,MAAM,GAAGH,OAAO,CAAC,UAAU,CAAC,CAACG,MAAM;EACnCC,aAAa,GAAGJ,OAAO,CAAC,aAAa,CAAC,CAACI,aAAa;EACpDC,cAAc,GAAGL,OAAO,CAAC,aAAa,CAAC,CAACK,cAAc;EACtDC,iBAAiB,GAAGN,OAAO,CAAC,aAAa,CAAC,CAACM,iBAAiB;EAC5DC,oBAAoB,GAAGP,OAAO,CAAC,aAAa,CAAC,CAACO,oBAAoB;EAClEC,IAAI,GAAGR,OAAO,CAAC,QAAQ,CAAC,CAACQ,IAAI;AAE/B,IAAIC,UAAU,GAAGC,OAAO,CAACD,UAAU,GAAG,YAAW,CACjD,CAAC;AAEDA,UAAU,CAACE,GAAG,GAAG,YAAW,CAC5B,CAAC;;AAED;AACAF,UAAU,CAACE,GAAG,CAACV,iBAAiB,GAAGA,iBAAiB;AACpDQ,UAAU,CAACE,GAAG,CAACT,aAAa,GAAGA,aAAa;AAC5CO,UAAU,CAACE,GAAG,CAACP,aAAa,GAAGA,aAAa;AAC5CK,UAAU,CAACE,GAAG,CAACN,cAAc,GAAGA,cAAc;AAC9CI,UAAU,CAACE,GAAG,CAACL,iBAAiB,GAAGA,iBAAiB;AACpDG,UAAU,CAACE,GAAG,CAACJ,oBAAoB,GAAGA,oBAAoB;AAC1DE,UAAU,CAACE,GAAG,CAACR,MAAM,GAAGA,MAAM;AAC9BM,UAAU,CAACE,GAAG,CAACH,IAAI,GAAGA,IAAI;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,UAAU,CAACE,GAAG,CAACC,KAAK,GAAG,UAASC,IAAI,EAAEC,IAAI,EAAEC,SAAS,EAAEC,KAAK,EAAE;EAC5DD,SAAS,GAAGA,SAAS,IAAI,IAAI,GAAGA,SAAS,GAAGN,UAAU,CAACE,GAAG,CAACN,cAAc;EAEzE,IAAGY,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACL,SAAS,CAAC,IAAI,mBAAmB,EAAE;IACnEA,SAAS,GAAG,IAAIA,SAAS,EAAE;EAC7B;;EAEA;EACAN,UAAU,CAACE,GAAG,CAACU,iBAAiB,CAACR,IAAI,EAAEC,IAAI,EAAEC,SAAS,CAAC;EACvD,IAAGA,SAAS,CAACO,MAAM,IAAI,IAAI,EAAEP,SAAS,CAACO,MAAM,EAAE;EAE/C,IAAGN,KAAK,IAAI,IAAI,EAAE;IAChB,IAAIO,GAAG,GAAGR,SAAS,CAACS,KAAK,CAACC,GAAG,CAAC,UAASC,IAAI,EAAE;MAC3C,IAAGC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;QACtBA,IAAI,GAAGA,IAAI,CAACD,GAAG,CAAC,UAASI,CAAC,EAAE;UAAE,OAAOb,KAAK,CAACa,CAAC,CAAC;QAAE,CAAC,CAAC;MACnD,CAAC,MAAM;QACLb,KAAK,CAACU,IAAI,CAAC;MACb;IACF,CAAC,CAAC;IAEF,OAAOH,GAAG;EACZ,CAAC,MAAM;IACL,OAAOR,SAAS,CAACS,KAAK;EACxB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAf,UAAU,CAACE,GAAG,CAACmB,IAAI,GAAG,UAASjB,IAAI,EAAEC,IAAI,EAAEC,SAAS,EAAEC,KAAK,EAAE;EAC3DD,SAAS,GAAGA,SAAS,IAAI,IAAI,GAAGA,SAAS,GAAGN,UAAU,CAACE,GAAG,CAACP,aAAa;EAExE,IAAGa,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACL,SAAS,CAAC,IAAI,mBAAmB,EAAE;IACnEA,SAAS,GAAG,IAAIA,SAAS,EAAE;EAC7B;;EAEA;EACAN,UAAU,CAACE,GAAG,CAACoB,kBAAkB,CAAClB,IAAI,EAAEC,IAAI,EAAEC,SAAS,CAAC;EACxD,IAAGA,SAAS,CAACO,MAAM,IAAI,IAAI,EAAEP,SAAS,CAACO,MAAM,EAAE;EAE/C,IAAGN,KAAK,IAAI,IAAI,EAAE;IAChB,IAAIO,GAAG,GAAGR,SAAS,CAACS,KAAK,CAACC,GAAG,CAAC,UAASC,IAAI,EAAE;MAC3C,IAAGC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;QACtBA,IAAI,GAAGA,IAAI,CAACD,GAAG,CAAC,UAASI,CAAC,EAAE;UAAE,OAAOb,KAAK,CAACa,CAAC,CAAC;QAAE,CAAC,CAAC;MACnD,CAAC,MAAM;QACLb,KAAK,CAACU,IAAI,CAAC;MACb;IACF,CAAC,CAAC;IAEF,OAAOH,GAAG;EACZ,CAAC,MAAM;IACL,OAAOR,SAAS,CAACS,KAAK;EACxB;AACF,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAf,UAAU,CAACE,GAAG,CAACoB,kBAAkB,GAAG,UAASlB,IAAI,EAAEC,IAAI,EAAEC,SAAS,EAAEC,KAAK,EAAE;EAAE;EAC3E;EACAD,SAAS,GAAGA,SAAS,IAAI,IAAI,GAAGA,SAAS,GAAG,IAAIN,UAAU,CAACE,GAAG,CAACV,iBAAiB,EAAE;EAClF;EACA,IAAI+B,OAAO,GAAGvB,UAAU,CAACE,GAAG,CAACsB,KAAK,CAACpB,IAAI,EAAEC,IAAI,CAAC;EAE9C,IAAIoB,cAAc,GAAG,KAAK;IAAEC,cAAc,GAAG,KAAK;EAClD,IAAIC,MAAM,GAAGvB,IAAI,CAACwB,WAAW,IAAIC,MAAM;EAEvC,IAAIC,MAAM,GAAG1B,IAAI,CAAC2B,MAAM;IAAEC,MAAM,GAAG3B,IAAI,CAAC0B,MAAM;EAC9C,IAAIE,EAAE,GAAG,CAAC;IAAEC,EAAE,GAAG,CAAC;EAClB,IAAIC,KAAK,GAAG,IAAI;EAEhB,KAAI,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,IAAIb,OAAO,CAACQ,MAAM,EAAEK,EAAE,EAAE,EAAE;IAC1C,IAAIC,MAAM,GAAGd,OAAO,CAACa,EAAE,CAAC;IAExB,IAAIE,EAAE,GAAGX,MAAM,GAAGvB,IAAI,CAACmC,MAAM,CAACH,EAAE,EAAE,CAAC,CAAC,GAAGhC,IAAI,CAACgC,EAAE,CAAC;IAC/C,IAAII,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAACL,EAAE,EAAEA,EAAE,GAAG,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;IAEpD,IAAGG,MAAM,IAAI,IAAI,EAAE;MACjB,IAAGC,EAAE,IAAI,IAAI,EAAE;QACbH,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAE2C,EAAE,EAAEE,EAAE,EAAEJ,EAAE,EAAEM,EAAE,CAAC;QAC7D,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;QACtC7B,SAAS,CAACmC,SAAS,CAACN,KAAK,CAAC;MAC5B;IACF,CAAC,MAAM;MACL,OAAMD,EAAE,GAAGG,MAAM,EAAE;QACjBG,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAACL,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;QAC3CC,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAE2C,EAAE,EAAEE,EAAE,EAAEJ,EAAE,EAAEM,EAAE,CAAC;QAC7D,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;QACtC7B,SAAS,CAACoC,SAAS,CAACP,KAAK,CAAC;QAC1BD,EAAE,GAAGA,EAAE,GAAG,CAAC;MACb;MAEAM,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAACL,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;MAC3CC,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAE2C,EAAE,EAAEE,EAAE,EAAEJ,EAAE,EAAEM,EAAE,CAAC;MAC7D,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;MACtC7B,SAAS,CAACqC,KAAK,CAACR,KAAK,CAAC;MACtBD,EAAE,GAAGA,EAAE,GAAG,CAAC;IACb;;IAEA;IACAD,EAAE,GAAGG,EAAE;EACT;;EAEA;EACAH,EAAE,GAAGA,EAAE,GAAG,CAAC;;EAEX;EACA;EACA,OAAMA,EAAE,GAAGH,MAAM,IAAII,EAAE,GAAGF,MAAM,EAAE;IAChC;IACA,IAAGC,EAAE,IAAIH,MAAM,IAAII,EAAE,GAAGF,MAAM,EAAE;MAC9B,IAAG1B,SAAS,CAACsC,UAAU,IAAI,IAAI,IAAI,CAACnB,cAAc,EAAE;QAClDa,EAAE,GAAGX,MAAM,GAAGvB,IAAI,CAACmC,MAAM,CAACnC,IAAI,CAAC2B,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG3B,IAAI,CAACA,IAAI,CAAC2B,MAAM,GAAG,CAAC,CAAC;QACrES,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAACL,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;QAC3CC,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAGqC,MAAM,GAAG,CAAC,EAAGQ,EAAE,EAAEJ,EAAE,EAAEM,EAAE,CAAC;QACvE,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;QACtC7B,SAAS,CAACsC,UAAU,CAACT,KAAK,CAAC;QAC3BV,cAAc,GAAG,IAAI;MACvB,CAAC,MAAM;QACLa,EAAE,GAAGX,MAAM,GAAGvB,IAAI,CAACmC,MAAM,CAACN,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;QAC3C,GAAG;UACDO,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAACL,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;UAC3CC,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAEwC,EAAE,EAAEK,EAAE,EAAEJ,EAAE,EAAEM,EAAE,CAAC;UAC7D,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;UACtC7B,SAAS,CAACoC,SAAS,CAACP,KAAK,CAAC;UAC1BD,EAAE,GAAGA,EAAE,GAAG,CAAC;QACb,CAAC,QAAOA,EAAE,GAAGF,MAAM;MACrB;IACF;;IAEA;IACA,IAAGE,EAAE,IAAIF,MAAM,IAAIC,EAAE,GAAGH,MAAM,EAAE;MAC9B,IAAGxB,SAAS,CAACuC,UAAU,IAAI,IAAI,IAAI,CAACnB,cAAc,EAAE;QAClDY,EAAE,GAAGX,MAAM,GAAGvB,IAAI,CAACmC,MAAM,CAACN,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;QAC3CO,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAAClC,IAAI,CAAC0B,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG1B,IAAI,CAACA,IAAI,CAAC0B,MAAM,GAAG,CAAC,CAAC;QACrEI,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAEwC,EAAE,EAAEK,EAAE,EAAGN,MAAM,GAAE,CAAC,EAAGQ,EAAE,CAAC;QACtE,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;QACtC7B,SAAS,CAACuC,UAAU,CAACV,KAAK,CAAC;QAC3BT,cAAc,GAAG,IAAI;MACvB,CAAC,MAAM;QACLc,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAACL,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;QAC3C,GAAG;UACDI,EAAE,GAAGX,MAAM,GAAGvB,IAAI,CAACmC,MAAM,CAACN,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;UAC3CE,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAEwC,EAAE,EAAEK,EAAE,EAAEJ,EAAE,EAAEM,EAAE,CAAC;UAC7D,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;UACtC7B,SAAS,CAACmC,SAAS,CAACN,KAAK,CAAC;UAC1BF,EAAE,GAAGA,EAAE,GAAG,CAAC;QACb,CAAC,QAAOC,EAAE,GAAGF,MAAM;MACrB;IACF;IAEA,IAAGC,EAAE,GAAGH,MAAM,EAAE;MACdQ,EAAE,GAAGX,MAAM,GAAGvB,IAAI,CAACmC,MAAM,CAACN,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;MAC3CO,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAACL,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;MAC3CC,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAEwC,EAAE,EAAEK,EAAE,EAAEJ,EAAE,EAAEM,EAAE,CAAC;MAC7D,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;MACtC7B,SAAS,CAACmC,SAAS,CAACN,KAAK,CAAC;MAC1BF,EAAE,GAAGA,EAAE,GAAG,CAAC;IACb;IAEA,IAAGC,EAAE,GAAGF,MAAM,EAAE;MACdM,EAAE,GAAGX,MAAM,GAAGvB,IAAI,CAACmC,MAAM,CAACN,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;MAC3CO,EAAE,GAAGb,MAAM,GAAGtB,IAAI,CAACkC,MAAM,CAACL,EAAE,EAAE,CAAC,CAAC,GAAG7B,IAAI,CAAC6B,EAAE,CAAC;MAC3CC,KAAK,GAAG,IAAInC,UAAU,CAACE,GAAG,CAACT,aAAa,CAAC,GAAG,EAAEwC,EAAE,EAAEK,EAAE,EAAEJ,EAAE,EAAEM,EAAE,CAAC;MAC7D,IAAGjC,KAAK,IAAI,IAAI,EAAE4B,KAAK,GAAG5B,KAAK,CAAC4B,KAAK,CAAC;MACtC7B,SAAS,CAACoC,SAAS,CAACP,KAAK,CAAC;MAC1BD,EAAE,GAAGA,EAAE,GAAG,CAAC;IACb;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlC,UAAU,CAACE,GAAG,CAACU,iBAAiB,GAAG,UAASR,IAAI,EAAEC,IAAI,EAAEC,SAAS,EAAEC,KAAK,EAAE;EACxE;EACAD,SAAS,GAAGA,SAAS,IAAI,IAAI,GAAGA,SAAS,GAAG,IAAIN,UAAU,CAACE,GAAG,CAACL,iBAAiB,EAAE;EAClF;EACA,IAAI0B,OAAO,GAAGvB,UAAU,CAACE,GAAG,CAACsB,KAAK,CAACpB,IAAI,EAAEC,IAAI,CAAC;EAC9C,IAAIyB,MAAM,GAAG1B,IAAI,CAAC2B,MAAM;EACxB,IAAIC,MAAM,GAAG3B,IAAI,CAAC0B,MAAM;EACxB,IAAIE,EAAE,GAAG,CAAC;IAAEC,EAAE,GAAG,CAAC;EAClB,IAAIY,EAAE,GAAG,CAAC;EACV,IAAIC,EAAE,GAAG,CAAC,CAAC;EACX,IAAIpB,MAAM,GAAGvB,IAAI,CAACwB,WAAW,IAAIC,MAAM;EACvC,IAAIS,EAAE,GAAG,IAAI;IAAEE,EAAE,GAAG,IAAI;IAAEL,KAAK,GAAG,IAAI;EACtC,IAAIa,OAAO,GAAG,IAAI;;EAElB;EACA,OAAM,IAAI,EAAE;IACV;IACA,OAAMA,OAAO,EAAE;MACbD,EAAE,GAAGA,EAAE,GAAG,CAAC;MACX,IAAG,EAAEA,EAAE,GA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"},"metadata":{},"sourceType":"script"}