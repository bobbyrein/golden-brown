{"ast":null,"code":"var Block = require('./block').Block;\n\n// A Hunk is a group of Blocks which overlap because of the context\n// surrounding each block. (So if we're not using context, every hunk will\n// contain one block.) Used in the diff program (bin/diff).\nvar Hunk = exports.Hunk = function (data_old, data_new, piece, context, file_length_difference) {\n  // Internal variables\n  var _flag_context = null;\n  var self = this;\n\n  // At first, a hunk will have just one Block in it\n  this.blocks = [new Block(piece)];\n  this.data_old = data_old;\n  this.data_new = data_new;\n  var before = file_length_difference,\n    after = file_length_difference;\n  after = after + this.blocks[0].diff_size;\n  this.file_length_difference = after; // The caller must get this manually\n  // Other parameters\n  var a1 = null,\n    a2 = null;\n  var b1 = null,\n    b2 = null;\n\n  // Save the start & end of each array. If the array doesn't exist\n  // (e.g., we're only adding items in this block), then figure out the\n  // line number based on the line number of the other file and the\n  // current difference in file lengths.\n  if (this.blocks[0].remove.length > 0) {\n    a1 = this.blocks[0].remove[0].position;\n    a2 = this.blocks[0].remove[this.blocks[0].remove.length - 1].position;\n  }\n  if (this.blocks[0].insert.length > 0) {\n    b1 = this.blocks[0].insert[0].position;\n    b2 = this.blocks[0].insert[this.blocks[0].insert.length - 1].position;\n  }\n  this.start_old = a1 || b1 - before;\n  this.start_new = b1 || a1 + before;\n  this.end_old = a2 || b2 - after;\n  this.end_new = b2 || a2 + after;\n\n  // Change the \"start\" and \"end\" fields to note that context should be added\n  // to this hunk\n  Object.defineProperty(this, \"flag_context\", {\n    get: function () {\n      return _flag_context;\n    },\n    set: function (context) {\n      if (context == null || context == 0) return null;\n      var add_start = context > self.start_old ? self.start_old : context;\n      var add_end = null;\n      self.start_old = self.start_old - add_start;\n      self.start_new = self.start_new - add_start;\n      if (self.end_old + context > self.data_old.length) {\n        add_end = self.data_old.length - self.end_old;\n      } else {\n        add_end = context;\n      }\n      self.end_old = self.end_old + add_end;\n      self.end_new = self.end_new + add_end;\n      _flag_context = context;\n    },\n    enumerable: true\n  });\n\n  // Set the flag_context\n  this.flag_context = context;\n};\nHunk.prototype.unshift = function (hunk) {\n  this.start_old = hunk.start_old;\n  this.start_new = hunk.start_new;\n  this.blocks = hunk.blocks.concat(this.blocks);\n};\n\n// Is there an overlap between hunk arg0 and old hunk arg1? Note: if end\n// of old hunk is one less than beginning of second, they overlap\nHunk.prototype.overlaps = function (hunk) {\n  if (hunk == null) return null;\n  var a = this.start_old - hunk.end_old <= 1;\n  var b = this.start_new - hunk.end_new <= 1;\n  return a || b;\n};\nHunk.prototype.diff = function (format) {\n  if (format == \"old\") {\n    return old_diff(this);\n  } else if (format == 'unified') {\n    return unified_diff(this);\n  } else if (format == 'context') {\n    return context_diff(this);\n  } else if (format == 'ed') {\n    return this;\n  } else if (format == 'reverse_ed' || format == 'ed_finish') {\n    return ed_diff(this, format);\n  } else {\n    throw \"unknown diff format \" + format;\n  }\n};\nHunk.prototype.each_old = function (block) {\n  var entries = this.data_old.slice(this.start_old, this.end_old);\n  entries.forEach(function (e) {\n    block(e);\n  });\n};\n\n// Note that an old diff can't have any context. Therefore, we know that\n// there's only one block in the hunk.\nvar old_diff = function (hunk) {\n  if (hunk.blocks.length > 1) sys.puts(\"expecting only one block in an old diff hunk!\");\n  // Set up operation actions\n  var opt_act = {\n    '+': 'a',\n    '-': 'd',\n    '!': 'c'\n  };\n  var block = hunk.blocks[0];\n\n  // Calculate item number range. Old diff range is just like a context\n  // diff range, except the ranges are on one line with the action between\n  // them.\n  var s = \"\" + context_rang(\"old\") + opt_act[block.op] + context_rang(\"new\") + \"\\n\";\n  // If removing anything, just print out all the remove lines in the hunk\n  // which is just all the remove lines in the block.\n  if (block.remove.length > 0) {\n    hunk.data_old.slice(hunk.start_old, hunk.end_old).forEach(function (e) {\n      s = s + \"< \" + e + \"\\n\";\n    });\n  }\n  if (block.insert.length > 0) {\n    hunk.data_new.slice(hunk.start_new, hunk.end_new).forEach(function (e) {\n      s = s + \"> \" + e + \"\\n;\";\n    });\n  }\n  // Return the diff string\n  return s;\n};\nvar unified_diff = function (hunk) {\n  // Calculate item number range.\n  var s = \"@@ -\" + unified_range(hunk, 'old') + \" +\" + unified_range(hunk, 'new') + \" @@\\n\";\n\n  // Outlist starts containing the hunk of the old file. Removing an item\n  // just means putting a '-' in front of it. Inserting an item requires\n  // getting it from the new file and splicing it in. We splice in\n  // +num_added+ items. Remove blocks use +num_added+ because splicing\n  // changed the length of outlist.\n  //\n  // We remove +num_removed+ items. Insert blocks use +num_removed+\n  // because their item numbers -- corresponding to positions in the NEW\n  // file -- don't take removed items into account.\n  var lo = hunk.start_old;\n  var hi = hunk.end_old;\n  var num_added = 0;\n  var num_removed = 0;\n\n  // Create list of stripped entries\n  var outlist = hunk.data_old.slice(lo, hi + 1).map(function (e) {\n    return e.replace(/^/g, ' ');\n  });\n  // Process all the blocks\n  hunk.blocks.forEach(function (block) {\n    block.remove.forEach(function (item) {\n      var op = item.action.toString(); // -\n      var offset = item.position - lo + num_added;\n      outlist[offset] = outlist[offset].replace(/^ /g, op.toString());\n      num_removed = num_removed + 1;\n    });\n    block.insert.forEach(function (item) {\n      var op = item.action.toString(); // +\n      var offset = item.position - hunk.start_new + num_removed;\n      outlist.splice(offset, 0, \"\" + op + hunk.data_new[item.position]);\n      num_added = num_added + 1;\n    });\n  });\n\n  // Return the list\n  return s + outlist.join('\\n');\n};\nvar context_diff = function (hunk) {\n  var s = '***************\\n';\n  s = s + '*** ' + context_range(hunk, 'old') + ' ****\\n';\n  // Retrieve the context\n  var r = context_range(hunk, 'new');\n  var outlist = null;\n\n  // Print out file 1 part for each block in context diff format if there\n  // are any blocks that remove items\n  var lo = hunk.start_old;\n  var hi = hunk.end_old;\n  var removes = hunk.blocks.filter(function (e) {\n    return !(e.remove.length == 0);\n  });\n  if (removes) {\n    outlist = hunk.data_old.slice(lo, hi).map(function (e) {\n      return e.replace(/^/g, '  ');\n    });\n    removes.forEach(function (block) {\n      block.remove.forEach(function (item) {\n        outlist[item.position - lo] = outlist[item.position - lo].replace(/^ /g, block.op); // - or !\n      });\n    });\n    // Add to diff string\n    s = s + outlist.join('\\n');\n  }\n  s = s + '\\n-- ' + r + ' ----\\n';\n  lo = hunk.start_new;\n  hi = hunk.end_new;\n  var inserts = hunk.blocks.filter(function (e) {\n    return !(e.insert.length == 0);\n  });\n  if (inserts) {\n    outlist = hunk.data_new.slice(lo, hi).map(function (e) {\n      return e.replace(/^/g, '  ');\n    });\n    inserts.forEach(function (block) {\n      block.insert.forEach(function (item) {\n        outlist[item.position - lo] = outlist[item.position - lo].replace(/^ /g, block.op); // + or !\n      });\n    });\n    // Add to diff string\n    s = s + outlist.join('\\n');\n  }\n  // Return the diff string\n  return s;\n};\nvar ed_diff = function (hunk, format) {\n  var opt_act = {\n    '+': 'a',\n    '-': 'd',\n    '!': 'c'\n  };\n  if (hunk.blocks.length > 1) sys.puts(\"expecting only one block in an old diff hunk!\");\n  var s = null;\n  if (format == 'reverse_ed') {\n    s = \"\" + op_act[hunk.blocks[0].op] + context_range(hunk, 'old') + '\\n';\n  } else {\n    s = \"\" + context_range(hunk, 'old').replace(/,/g, ' ') + op_act[hunk.blocks[0].op] + '\\n';\n  }\n  if (hunk.blocks[0].insert.length > 0) {\n    hunk.data_new.slice(hunk.start_new, hunk.end_new).forEach(function (e) {\n      s = s + '' + e + '\\n';\n    });\n    // Add final marker\n    s = s + '.\\n';\n  }\n  // Return diff string\n  return s;\n};\n\n// Generate a range of item numbers to print. Only print 1 number if the\n// range has only one item in it. Otherwise, it's 'start,end'\nvar context_range = function (hunk, mode) {\n  var s = null,\n    e = null;\n  if (mode == 'old') {\n    s = hunk.start_old + 1;\n    e = hunk.end_old + 1;\n  } else if (mode == 'new') {\n    s = hunk.start_new + 1;\n    e = hunk.end_new + 1;\n  }\n  return s < e ? \"\" + s + \",\" + e : \"\" + e;\n};\n\n// Generate a range of item numbers to print for unified diff. Print\n// number where block starts, followed by number of lines in the block\n// (don't print number of lines if it's 1)\nvar unified_range = function (hunk, mode) {\n  var s = null,\n    e = null;\n  if (mode == 'old') {\n    s = hunk.start_old + 1;\n    e = hunk.end_old + 1;\n  } else if (mode == 'new') {\n    s = hunk.start_new + 1;\n    e = hunk.end_new + 1;\n  }\n  var length = e - s + 1;\n  var first = length < 2 ? e : s; // something weird   \n  return length == 1 ? \"\" + first : first + \",\" + length;\n};","map":{"version":3,"names":["Block","require","Hunk","exports","data_old","data_new","piece","context","file_length_difference","_flag_context","self","blocks","before","after","diff_size","a1","a2","b1","b2","remove","length","position","insert","start_old","start_new","end_old","end_new","Object","defineProperty","get","set","add_start","add_end","enumerable","flag_context","prototype","unshift","hunk","concat","overlaps","a","b","diff","format","old_diff","unified_diff","context_diff","ed_diff","each_old","block","entries","slice","forEach","e","sys","puts","opt_act","s","context_rang","op","unified_range","lo","hi","num_added","num_removed","outlist","map","replace","item","action","toString","offset","splice","join","context_range","r","removes","filter","inserts","op_act","mode","first"],"sources":["/Users/bobbyrein/react-course/golden-brown/node_modules/git/lib/diff/hunk.js"],"sourcesContent":["var Block = require('./block').Block;\n\n// A Hunk is a group of Blocks which overlap because of the context\n// surrounding each block. (So if we're not using context, every hunk will\n// contain one block.) Used in the diff program (bin/diff).\nvar Hunk = exports.Hunk = function(data_old, data_new, piece, context, file_length_difference) {  \n  // Internal variables\n  var _flag_context = null;\n  var self = this;\n  \n  // At first, a hunk will have just one Block in it\n  this.blocks = [new Block(piece)];\n  this.data_old = data_old;\n  this.data_new = data_new;\n  \n  var before = file_length_difference, after = file_length_difference;\n  after = after + this.blocks[0].diff_size;\n  this.file_length_difference = after; // The caller must get this manually\n  // Other parameters\n  var a1 = null, a2 = null;\n  var b1 = null, b2 = null;\n  \n  // Save the start & end of each array. If the array doesn't exist\n  // (e.g., we're only adding items in this block), then figure out the\n  // line number based on the line number of the other file and the\n  // current difference in file lengths.\n  if(this.blocks[0].remove.length > 0) {\n    a1 = this.blocks[0].remove[0].position;\n    a2 = this.blocks[0].remove[this.blocks[0].remove.length - 1].position;\n  }\n  \n  if(this.blocks[0].insert.length > 0) {\n    b1 = this.blocks[0].insert[0].position;\n    b2 = this.blocks[0].insert[this.blocks[0].insert.length - 1].position;\n  }\n    \n  this.start_old = a1 || (b1 - before);\n  this.start_new = b1 || (a1 + before);\n  this.end_old = a2 || (b2 - after);\n  this.end_new = b2 || (a2 + after);    \n  \n  // Change the \"start\" and \"end\" fields to note that context should be added\n  // to this hunk\n  Object.defineProperty(this, \"flag_context\", { get: function() { return _flag_context; }, set: function(context) { \n      if(context == null || context == 0) return null;\n      \n      var add_start = (context > self.start_old) ? self.start_old : context;\n      var add_end = null;\n      \n      self.start_old = self.start_old - add_start;\n      self.start_new = self.start_new - add_start;\n      \n      if((self.end_old + context) > self.data_old.length) {\n        add_end = self.data_old.length - self.end_old;\n      } else {\n        add_end = context;\n      }\n      \n      self.end_old = self.end_old + add_end;\n      self.end_new = self.end_new + add_end;\n      _flag_context = context;\n    }, enumerable: true});   \n    \n  // Set the flag_context\n  this.flag_context = context;     \n}\n\nHunk.prototype.unshift = function(hunk) {\n  this.start_old = hunk.start_old;\n  this.start_new = hunk.start_new;\n  this.blocks = hunk.blocks.concat(this.blocks);\n}\n\n// Is there an overlap between hunk arg0 and old hunk arg1? Note: if end\n// of old hunk is one less than beginning of second, they overlap\nHunk.prototype.overlaps = function(hunk) {\n  if(hunk == null) return null;\n  \n  var a = (this.start_old - hunk.end_old) <= 1;\n  var b = (this.start_new - hunk.end_new) <= 1;\n  return (a || b);\n}\n\nHunk.prototype.diff = function(format) {\n  if(format == \"old\") {\n    return old_diff(this);    \n  } else if(format == 'unified') {\n    return unified_diff(this);\n  } else if(format == 'context') {\n    return context_diff(this);\n  } else if(format == 'ed') {\n    return this;\n  } else if(format == 'reverse_ed' || format == 'ed_finish') {\n    return ed_diff(this, format);\n  } else {\n    throw \"unknown diff format \" + format;\n  }\n}\n\nHunk.prototype.each_old = function(block) {\n  var entries = this.data_old.slice(this.start_old, this.end_old);\n  entries.forEach(function(e) {\n    block(e);\n  });\n}\n\n// Note that an old diff can't have any context. Therefore, we know that\n// there's only one block in the hunk.\nvar old_diff = function(hunk) {\n  if(hunk.blocks.length > 1) sys.puts(\"expecting only one block in an old diff hunk!\");\n  // Set up operation actions\n  var opt_act = {'+':'a', '-':'d', '!':'c'};\n  var block = hunk.blocks[0];\n  \n  // Calculate item number range. Old diff range is just like a context\n  // diff range, except the ranges are on one line with the action between\n  // them.\n  var s = \"\" + context_rang(\"old\") + opt_act[block.op] + context_rang(\"new\") + \"\\n\";\n  // If removing anything, just print out all the remove lines in the hunk\n  // which is just all the remove lines in the block.\n  if(block.remove.length > 0) {\n    hunk.data_old.slice(hunk.start_old, hunk.end_old).forEach(function(e) {\n      s = s + \"< \" + e + \"\\n\";\n    });    \n  }\n  \n  if(block.insert.length > 0) {\n    hunk.data_new.slice(hunk.start_new, hunk.end_new).forEach(function(e) {\n      s = s + \"> \" + e + \"\\n;\"\n    });\n  }\n  // Return the diff string\n  return s;\n}\n\nvar unified_diff = function(hunk) {\n  // Calculate item number range.\n  var s = \"@@ -\" + unified_range(hunk, 'old') + \" +\" + unified_range(hunk, 'new') + \" @@\\n\";\n\n  // Outlist starts containing the hunk of the old file. Removing an item\n  // just means putting a '-' in front of it. Inserting an item requires\n  // getting it from the new file and splicing it in. We splice in\n  // +num_added+ items. Remove blocks use +num_added+ because splicing\n  // changed the length of outlist.\n  //\n  // We remove +num_removed+ items. Insert blocks use +num_removed+\n  // because their item numbers -- corresponding to positions in the NEW\n  // file -- don't take removed items into account.\n  var lo = hunk.start_old;\n  var hi = hunk.end_old;\n  var num_added = 0;\n  var num_removed = 0;\n  \n  // Create list of stripped entries\n  var outlist = hunk.data_old.slice(lo, hi + 1).map(function(e) { return e.replace(/^/g, ' '); });\n  // Process all the blocks\n  hunk.blocks.forEach(function(block) {\n    block.remove.forEach(function(item) {\n      var op = item.action.toString();  // -\n      var offset = item.position - lo + num_added;\n      outlist[offset] = outlist[offset].replace(/^ /g, op.toString());\n      num_removed = num_removed + 1;\n    })\n    \n    block.insert.forEach(function(item) {\n      var op = item.action.toString(); // +\n      var offset = item.position - hunk.start_new + num_removed;\n      outlist.splice(offset, 0, (\"\" + op + hunk.data_new[item.position]));\n      num_added = num_added + 1;\n    });\n  });\n  \n  // Return the list\n  return s + outlist.join('\\n');\n}\n\nvar context_diff = function(hunk) {\n  var s = '***************\\n';\n  s = s + '*** ' + context_range(hunk, 'old') + ' ****\\n';\n  // Retrieve the context\n  var r = context_range(hunk, 'new');\n  var outlist = null;\n  \n  // Print out file 1 part for each block in context diff format if there\n  // are any blocks that remove items\n  var lo = hunk.start_old;\n  var hi = hunk.end_old;\n  var removes = hunk.blocks.filter(function(e) { return !(e.remove.length == 0); });\n  \n  if(removes) {\n    outlist = hunk.data_old.slice(lo, hi).map(function(e) { return e.replace(/^/g, '  '); });\n    removes.forEach(function(block) {\n      block.remove.forEach(function(item) {\n        outlist[item.position - lo] = outlist[item.position - lo].replace(/^ /g, block.op); // - or !\n      });\n    });\n    // Add to diff string\n    s = s + outlist.join('\\n');\n  }\n  \n  s = s + '\\n-- ' + r + ' ----\\n';\n  lo = hunk.start_new;\n  hi = hunk.end_new;\n  var inserts = hunk.blocks.filter(function(e) { return !(e.insert.length == 0); });\n\n  if(inserts) {\n    outlist = hunk.data_new.slice(lo, hi).map(function(e) { return e.replace(/^/g, '  '); });\n    inserts.forEach(function(block) {\n      block.insert.forEach(function(item) {\n        outlist[item.position - lo] = outlist[item.position - lo].replace(/^ /g, block.op); // + or !\n      });\n    });\n    // Add to diff string\n    s = s + outlist.join('\\n');    \n  }\n  // Return the diff string\n  return s;\n}\n\nvar ed_diff = function(hunk, format) {\n  var opt_act = {'+':'a', '-':'d', '!':'c'};\n  if(hunk.blocks.length > 1) sys.puts(\"expecting only one block in an old diff hunk!\");\n  var s = null;\n  \n  if(format == 'reverse_ed') {\n    s = \"\" + op_act[hunk.blocks[0].op] + context_range(hunk, 'old') + '\\n';\n  } else {\n    s = \"\" + context_range(hunk, 'old').replace(/,/g, ' ') + op_act[hunk.blocks[0].op] + '\\n';\n  }\n  \n  if(hunk.blocks[0].insert.length > 0) {\n    hunk.data_new.slice(hunk.start_new, hunk.end_new).forEach(function(e) {\n      s = s + '' + e + '\\n';\n    });\n    // Add final marker\n    s = s + '.\\n';\n  }\n  // Return diff string\n  return s;\n}\n\n// Generate a range of item numbers to print. Only print 1 number if the\n// range has only one item in it. Otherwise, it's 'start,end'\nvar context_range = function(hunk, mode) {\n  var s = null, e = null;\n  \n  if(mode == 'old') {\n    s = (hunk.start_old + 1);\n    e = (hunk.end_old + 1);\n  } else if(mode == 'new') {\n    s = (hunk.start_new + 1);\n    e = (hunk.end_new + 1);    \n  }\n  \n  return (s < e) ? (\"\" + s + \",\" + e) : (\"\" + e);\n}\n\n// Generate a range of item numbers to print for unified diff. Print\n// number where block starts, followed by number of lines in the block\n// (don't print number of lines if it's 1)\nvar unified_range = function(hunk, mode) {\n  var s = null, e = null;\n  \n  if(mode == 'old') {\n    s = (hunk.start_old + 1);\n    e = (hunk.end_old + 1);\n  } else if(mode == 'new') {\n    s = (hunk.start_new + 1);\n    e = (hunk.end_new + 1);\n  }\n  \n  var length = e - s + 1;\n  var first = (length < 2) ? e : s;   // something weird   \n  return (length == 1) ? (\"\" + first) : (first + \",\" + length);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}