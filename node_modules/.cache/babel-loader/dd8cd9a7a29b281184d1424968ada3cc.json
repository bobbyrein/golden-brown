{"ast":null,"code":"var ContextChange = require('./change').ContextChange,\n  Change = require('./change').Change;\n\n// This callback object implements the default set of callback events, which\n// only returns the event itself. Note that //finished_a and //finished_b are\n// not implemented -- I haven't yet figured out where they would be useful.\n//\n// Note that this is intended to be called as is, e.g.,\nDefaultCallbacks = exports.DefaultCallbacks = function () {};\n\n// Called when two items match.\nDefaultCallbacks.prototype.match = function (event) {\n  return event;\n};\n\n// Called when the old value is discarded in favour of the new value.\nDefaultCallbacks.prototype.discard_a = function (event) {\n  return event;\n};\n\n// Called when the new value is discarded in favour of the old value.\nDefaultCallbacks.prototype.discard_b = function (event) {\n  return event;\n};\n\n// Called when both the old and new values have changed.\nDefaultCallbacks.prototype.change = function (event) {\n  return event;\n};\n\n// An alias for DefaultCallbacks that is used in Diff::LCS#traverse_sequences.\nSequenceCallbacks = exports.SequenceCallbacks = DefaultCallbacks;\n// An alias for DefaultCallbacks that is used in Diff::LCS#traverse_balanced.\nBalancedCallbacks = exports.BalancedCallbacks = DefaultCallbacks;\n\n// This will produce a compound array of simple diff change objects. Each\n// element in the //diffs array is a +hunk+ or +hunk+ array, where each\n// element in each +hunk+ array is a single Change object representing the\n// addition or removal of a single element from one of the two tested\n// sequences. The +hunk+ provides the full context for the changes.\n//\n//     diffs = Diff::LCS.diff(seq1, seq2)\n//       // This example shows a simplified array format.\n//       // [ [ [ '-',  0, 'a' ] ],   // 1\n//       //   [ [ '+',  2, 'd' ] ],   // 2\n//       //   [ [ '-',  4, 'h' ],     // 3\n//       //     [ '+',  4, 'f' ] ],\n//       //   [ [ '+',  6, 'k' ] ],   // 4\n//       //   [ [ '-',  8, 'n' ],     // 5\n//       //     [ '-',  9, 'p' ],\n//       //     [ '+',  9, 'r' ],\n//       //     [ '+', 10, 's' ],\n//       //     [ '+', 11, 't' ] ] ]\n//\n// There are five hunks here. The first hunk says that the +a+ at position 0\n// of the first sequence should be deleted (<tt>'-'</tt>). The second hunk\n// says that the +d+ at position 2 of the second sequence should be inserted\n// (<tt>'+'</tt>). The third hunk says that the +h+ at position 4 of the\n// first sequence should be removed and replaced with the +f+ from position 4\n// of the second sequence. The other two hunks are described similarly.\n//\n// === Use\n// This callback object must be initialised and is used by the Diff::LCS//diff\n// method.\n//\n//     cbo = Diff::LCS::DiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//     cbo.finish\n//\n// Note that the call to //finish is absolutely necessary, or the last set of\n// changes will not be visible. Alternatively, can be used as:\n//\n//     cbo = Diff::LCS::DiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// The necessary //finish call will be made.\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.map { |f| f.to_a } }\nDiffCallbacks = exports.DiffCallbacks = function (block) {\n  this.hunk = [];\n  this.diffs = [];\n  if (block != null) {\n    block(this);\n    this.finish();\n  }\n};\n\n// Finalizes the diff process. If an unprocessed hunk still exists, then it\n// is appended to the diff list.\nDiffCallbacks.prototype.finish = function () {\n  add_nonempty_hunk(this);\n};\nDiffCallbacks.prototype.match = function (event) {\n  add_nonempty_hunk(this);\n};\nDiffCallbacks.prototype.discard_a = function (event) {\n  this.hunk.push(new Change('-', event.old_position, event.old_element));\n};\nDiffCallbacks.prototype.discard_b = function (event) {\n  this.hunk.push(new Change('+', event.new_position, event.new_element));\n};\nvar add_nonempty_hunk = function (diff_callback) {\n  if (diff_callback.hunk.length > 0) diff_callback.diffs.push(diff_callback.hunk);\n  diff_callback.hunk = [];\n};\n\n// This will produce a simple array of diff change objects. Each element in\n// the //diffs array is a single ContextChange. In the set of //diffs provided\n// by SDiffCallbacks, both old and new objects will be presented for both\n// changed <strong>and unchanged</strong> objects. +nil+ will be substituted\n// for a discarded object.\n//\n// The diffset produced by this callback, when provided to Diff::LCS//sdiff,\n// will compute and display the necessary components to show two sequences\n// and their minimized differences side by side, just like the Unix utility\n// +sdiff+.\n// \n//     same             same\n//     before     |     after\n//     old        <     -\n//     -          >     new\n//\n//     seq1 = %w(a b c e h j l m n p)\n//     seq2 = %w(b c d e f j k l m r s t)\n//\n//     diffs = Diff::LCS.sdiff(seq1, seq2)\n//       // This example shows a simplified array format.\n//       // [ [ \"-\", [  0, \"a\"], [  0, nil ] ],\n//       //   [ \"=\", [  1, \"b\"], [  0, \"b\" ] ],\n//       //   [ \"=\", [  2, \"c\"], [  1, \"c\" ] ],\n//       //   [ \"+\", [  3, nil], [  2, \"d\" ] ],\n//       //   [ \"=\", [  3, \"e\"], [  3, \"e\" ] ],\n//       //   [ \"!\", [  4, \"h\"], [  4, \"f\" ] ],\n//       //   [ \"=\", [  5, \"j\"], [  5, \"j\" ] ],\n//       //   [ \"+\", [  6, nil], [  6, \"k\" ] ],\n//       //   [ \"=\", [  6, \"l\"], [  7, \"l\" ] ],\n//       //   [ \"=\", [  7, \"m\"], [  8, \"m\" ] ],\n//       //   [ \"!\", [  8, \"n\"], [  9, \"r\" ] ],\n//       //   [ \"!\", [  9, \"p\"], [ 10, \"s\" ] ],\n//       //   [ \"+\", [ 10, nil], [ 11, \"t\" ] ] ]\n//\n// The result of this operation is similar to that of\n// Diff::LCS::ContextDiffCallbacks. They may be compared as:\n//\n//     s = Diff::LCS.sdiff(seq1, seq2).reject { |e| e.action == \"=\" }\n//     c = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextDiffCallbacks).flatten\n//\n//     s == c // -> true\n//\n// === Use\n// This callback object must be initialised and is used by the Diff::LCS//sdiff\n// method.\n//\n//     cbo = Diff::LCS::SDiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//\n// As with the other initialisable callback objects, Diff::LCS::SDiffCallbacks\n// can be initialised with a block. As there is no \"fininishing\" to be done,\n// this has no effect on the state of the object.\n//\n//     cbo = Diff::LCS::SDiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.to_a }\nSDiffCallbacks = exports.SDiffCallbacks = function (block) {\n  this.diffs = [];\n  if (block != null) {\n    block(this);\n    this.finish();\n  }\n};\nSDiffCallbacks.prototype.match = function (event) {\n  this.diffs.push(ContextChange.simplify(event));\n};\nSDiffCallbacks.prototype.discard_a = function (event) {\n  this.diffs.push(ContextChange.simplify(event));\n};\nSDiffCallbacks.prototype.discard_b = function (event) {\n  this.diffs.push(ContextChange.simplify(event));\n};\nSDiffCallbacks.prototype.change = function (event) {\n  this.diffs.push(ContextChange.simplify(event));\n};\n\n// This will produce a compound array of contextual diff change objects. Each\n// element in the //diffs array is a \"hunk\" array, where each element in each\n// \"hunk\" array is a single change. Each change is a Diff::LCS::ContextChange\n// that contains both the old index and new index values for the change. The\n// \"hunk\" provides the full context for the changes. Both old and new objects\n// will be presented for changed objects. +nil+ will be substituted for a\n// discarded object.\n//\n//     seq1 = %w(a b c e h j l m n p)\n//     seq2 = %w(b c d e f j k l m r s t)\n//\n//     diffs = Diff::LCS.diff(seq1, seq2, Diff::LCS::ContextDiffCallbacks)\n//       // This example shows a simplified array format.\n//       // [ [ [ '-', [  0, 'a' ], [  0, nil ] ] ],   // 1\n//       //   [ [ '+', [  3, nil ], [  2, 'd' ] ] ],   // 2\n//       //   [ [ '-', [  4, 'h' ], [  4, nil ] ],     // 3\n//       //     [ '+', [  5, nil ], [  4, 'f' ] ] ],\n//       //   [ [ '+', [  6, nil ], [  6, 'k' ] ] ],   // 4\n//       //   [ [ '-', [  8, 'n' ], [  9, nil ] ],     // 5\n//       //     [ '+', [  9, nil ], [  9, 'r' ] ],\n//       //     [ '-', [  9, 'p' ], [ 10, nil ] ],\n//       //     [ '+', [ 10, nil ], [ 10, 's' ] ],\n//       //     [ '+', [ 10, nil ], [ 11, 't' ] ] ] ]\n//\n// The five hunks shown are comprised of individual changes; if there is a\n// related set of changes, they are still shown individually.\n//\n// This callback can also be used with Diff::LCS//sdiff, which will produce\n// results like:\n//\n//     diffs = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextCallbacks)\n//       // This example shows a simplified array format.\n//       // [ [ [ \"-\", [  0, \"a\" ], [  0, nil ] ] ],  // 1\n//       //   [ [ \"+\", [  3, nil ], [  2, \"d\" ] ] ],  // 2\n//       //   [ [ \"!\", [  4, \"h\" ], [  4, \"f\" ] ] ],  // 3\n//       //   [ [ \"+\", [  6, nil ], [  6, \"k\" ] ] ],  // 4\n//       //   [ [ \"!\", [  8, \"n\" ], [  9, \"r\" ] ],    // 5\n//       //     [ \"!\", [  9, \"p\" ], [ 10, \"s\" ] ],\n//       //     [ \"+\", [ 10, nil ], [ 11, \"t\" ] ] ] ]\n//\n// The five hunks are still present, but are significantly shorter in total\n// presentation, because changed items are shown as changes (\"!\") instead of\n// potentially \"mismatched\" pairs of additions and deletions.\n//\n// The result of this operation is similar to that of\n// Diff::LCS::SDiffCallbacks. They may be compared as:\n//\n//     s = Diff::LCS.sdiff(seq1, seq2).reject { |e| e.action == \"=\" }\n//     c = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextDiffCallbacks).flatten\n//\n//     s == c // -> true\n//\n// === Use\n// This callback object must be initialised and can be used by the\n// Diff::LCS//diff or Diff::LCS//sdiff methods.\n//\n//     cbo = Diff::LCS::ContextDiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//     cbo.finish\n//\n// Note that the call to //finish is absolutely necessary, or the last set of\n// changes will not be visible. Alternatively, can be used as:\n//\n//     cbo = Diff::LCS::ContextDiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// The necessary //finish call will be made.\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.map { |f| f.to_a } }\nContextDiffCallbacks = exports.ContextDiffCallbacks = function (block) {\n  this.hunk = [];\n  this.diffs = [];\n  if (block != null) {\n    block(this);\n    this.finish();\n  }\n};\nContextDiffCallbacks.prototype.finish = function () {\n  add_nonempty_hunk(this);\n};\nContextDiffCallbacks.prototype.discard_a = function (event) {\n  this.hunk.push(ContextChange.simplify(event));\n};\nContextDiffCallbacks.prototype.discard_b = function (event) {\n  this.hunk.push(ContextChange.simplify(event));\n};\nContextDiffCallbacks.prototype.match = function (event) {\n  this.hunk.push(ContextChange.simplify(event));\n};","map":{"version":3,"names":["ContextChange","require","Change","DefaultCallbacks","exports","prototype","match","event","discard_a","discard_b","change","SequenceCallbacks","BalancedCallbacks","DiffCallbacks","block","hunk","diffs","finish","add_nonempty_hunk","push","old_position","old_element","new_position","new_element","diff_callback","length","SDiffCallbacks","simplify","ContextDiffCallbacks"],"sources":["/Users/bobbyrein/react-course/golden-brown/node_modules/git/lib/diff/callbacks.js"],"sourcesContent":["var ContextChange = require('./change').ContextChange,\n  Change = require('./change').Change;\n\n// This callback object implements the default set of callback events, which\n// only returns the event itself. Note that //finished_a and //finished_b are\n// not implemented -- I haven't yet figured out where they would be useful.\n//\n// Note that this is intended to be called as is, e.g.,\nDefaultCallbacks = exports.DefaultCallbacks = function() {  \n}\n\n// Called when two items match.\nDefaultCallbacks.prototype.match = function(event) {\n  return event;\n}\n\n// Called when the old value is discarded in favour of the new value.\nDefaultCallbacks.prototype.discard_a = function(event) {\n  return event;\n}\n\n// Called when the new value is discarded in favour of the old value.\nDefaultCallbacks.prototype.discard_b = function(event) {\n  return event;\n}\n\n// Called when both the old and new values have changed.\nDefaultCallbacks.prototype.change = function(event) {\n  return event;\n}\n\n// An alias for DefaultCallbacks that is used in Diff::LCS#traverse_sequences.\nSequenceCallbacks = exports.SequenceCallbacks = DefaultCallbacks;\n// An alias for DefaultCallbacks that is used in Diff::LCS#traverse_balanced.\nBalancedCallbacks = exports.BalancedCallbacks = DefaultCallbacks;\n\n// This will produce a compound array of simple diff change objects. Each\n// element in the //diffs array is a +hunk+ or +hunk+ array, where each\n// element in each +hunk+ array is a single Change object representing the\n// addition or removal of a single element from one of the two tested\n// sequences. The +hunk+ provides the full context for the changes.\n//\n//     diffs = Diff::LCS.diff(seq1, seq2)\n//       // This example shows a simplified array format.\n//       // [ [ [ '-',  0, 'a' ] ],   // 1\n//       //   [ [ '+',  2, 'd' ] ],   // 2\n//       //   [ [ '-',  4, 'h' ],     // 3\n//       //     [ '+',  4, 'f' ] ],\n//       //   [ [ '+',  6, 'k' ] ],   // 4\n//       //   [ [ '-',  8, 'n' ],     // 5\n//       //     [ '-',  9, 'p' ],\n//       //     [ '+',  9, 'r' ],\n//       //     [ '+', 10, 's' ],\n//       //     [ '+', 11, 't' ] ] ]\n//\n// There are five hunks here. The first hunk says that the +a+ at position 0\n// of the first sequence should be deleted (<tt>'-'</tt>). The second hunk\n// says that the +d+ at position 2 of the second sequence should be inserted\n// (<tt>'+'</tt>). The third hunk says that the +h+ at position 4 of the\n// first sequence should be removed and replaced with the +f+ from position 4\n// of the second sequence. The other two hunks are described similarly.\n//\n// === Use\n// This callback object must be initialised and is used by the Diff::LCS//diff\n// method.\n//\n//     cbo = Diff::LCS::DiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//     cbo.finish\n//\n// Note that the call to //finish is absolutely necessary, or the last set of\n// changes will not be visible. Alternatively, can be used as:\n//\n//     cbo = Diff::LCS::DiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// The necessary //finish call will be made.\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.map { |f| f.to_a } }\nDiffCallbacks = exports.DiffCallbacks = function(block) {\n  this.hunk = [];\n  this.diffs = [];\n  \n  if(block != null)  {\n    block(this);\n    this.finish();\n  }\n}\n\n// Finalizes the diff process. If an unprocessed hunk still exists, then it\n// is appended to the diff list.\nDiffCallbacks.prototype.finish = function() {\n  add_nonempty_hunk(this);\n}\n\nDiffCallbacks.prototype.match = function(event) {\n  add_nonempty_hunk(this);\n}\n\nDiffCallbacks.prototype.discard_a = function(event) {\n  this.hunk.push(new Change('-', event.old_position, event.old_element));\n}\n\nDiffCallbacks.prototype.discard_b = function(event) {\n  this.hunk.push(new Change('+', event.new_position, event.new_element));\n}\n\nvar add_nonempty_hunk = function(diff_callback) {\n  if(diff_callback.hunk.length > 0) diff_callback.diffs.push(diff_callback.hunk);\n  diff_callback.hunk = [];\n}\n\n// This will produce a simple array of diff change objects. Each element in\n// the //diffs array is a single ContextChange. In the set of //diffs provided\n// by SDiffCallbacks, both old and new objects will be presented for both\n// changed <strong>and unchanged</strong> objects. +nil+ will be substituted\n// for a discarded object.\n//\n// The diffset produced by this callback, when provided to Diff::LCS//sdiff,\n// will compute and display the necessary components to show two sequences\n// and their minimized differences side by side, just like the Unix utility\n// +sdiff+.\n// \n//     same             same\n//     before     |     after\n//     old        <     -\n//     -          >     new\n//\n//     seq1 = %w(a b c e h j l m n p)\n//     seq2 = %w(b c d e f j k l m r s t)\n//\n//     diffs = Diff::LCS.sdiff(seq1, seq2)\n//       // This example shows a simplified array format.\n//       // [ [ \"-\", [  0, \"a\"], [  0, nil ] ],\n//       //   [ \"=\", [  1, \"b\"], [  0, \"b\" ] ],\n//       //   [ \"=\", [  2, \"c\"], [  1, \"c\" ] ],\n//       //   [ \"+\", [  3, nil], [  2, \"d\" ] ],\n//       //   [ \"=\", [  3, \"e\"], [  3, \"e\" ] ],\n//       //   [ \"!\", [  4, \"h\"], [  4, \"f\" ] ],\n//       //   [ \"=\", [  5, \"j\"], [  5, \"j\" ] ],\n//       //   [ \"+\", [  6, nil], [  6, \"k\" ] ],\n//       //   [ \"=\", [  6, \"l\"], [  7, \"l\" ] ],\n//       //   [ \"=\", [  7, \"m\"], [  8, \"m\" ] ],\n//       //   [ \"!\", [  8, \"n\"], [  9, \"r\" ] ],\n//       //   [ \"!\", [  9, \"p\"], [ 10, \"s\" ] ],\n//       //   [ \"+\", [ 10, nil], [ 11, \"t\" ] ] ]\n//\n// The result of this operation is similar to that of\n// Diff::LCS::ContextDiffCallbacks. They may be compared as:\n//\n//     s = Diff::LCS.sdiff(seq1, seq2).reject { |e| e.action == \"=\" }\n//     c = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextDiffCallbacks).flatten\n//\n//     s == c // -> true\n//\n// === Use\n// This callback object must be initialised and is used by the Diff::LCS//sdiff\n// method.\n//\n//     cbo = Diff::LCS::SDiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//\n// As with the other initialisable callback objects, Diff::LCS::SDiffCallbacks\n// can be initialised with a block. As there is no \"fininishing\" to be done,\n// this has no effect on the state of the object.\n//\n//     cbo = Diff::LCS::SDiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.to_a }\nSDiffCallbacks = exports.SDiffCallbacks = function(block) {\n  this.diffs = [];\n  \n  if(block != null)  {\n    block(this);\n    this.finish();\n  }\n}\n\nSDiffCallbacks.prototype.match = function(event) {\n  this.diffs.push(ContextChange.simplify(event));\n}\n\nSDiffCallbacks.prototype.discard_a = function(event) {\n  this.diffs.push(ContextChange.simplify(event));\n}\n\nSDiffCallbacks.prototype.discard_b = function(event) {\n  this.diffs.push(ContextChange.simplify(event));\n}\n\nSDiffCallbacks.prototype.change = function(event) {\n  this.diffs.push(ContextChange.simplify(event));\n}\n\n// This will produce a compound array of contextual diff change objects. Each\n// element in the //diffs array is a \"hunk\" array, where each element in each\n// \"hunk\" array is a single change. Each change is a Diff::LCS::ContextChange\n// that contains both the old index and new index values for the change. The\n// \"hunk\" provides the full context for the changes. Both old and new objects\n// will be presented for changed objects. +nil+ will be substituted for a\n// discarded object.\n//\n//     seq1 = %w(a b c e h j l m n p)\n//     seq2 = %w(b c d e f j k l m r s t)\n//\n//     diffs = Diff::LCS.diff(seq1, seq2, Diff::LCS::ContextDiffCallbacks)\n//       // This example shows a simplified array format.\n//       // [ [ [ '-', [  0, 'a' ], [  0, nil ] ] ],   // 1\n//       //   [ [ '+', [  3, nil ], [  2, 'd' ] ] ],   // 2\n//       //   [ [ '-', [  4, 'h' ], [  4, nil ] ],     // 3\n//       //     [ '+', [  5, nil ], [  4, 'f' ] ] ],\n//       //   [ [ '+', [  6, nil ], [  6, 'k' ] ] ],   // 4\n//       //   [ [ '-', [  8, 'n' ], [  9, nil ] ],     // 5\n//       //     [ '+', [  9, nil ], [  9, 'r' ] ],\n//       //     [ '-', [  9, 'p' ], [ 10, nil ] ],\n//       //     [ '+', [ 10, nil ], [ 10, 's' ] ],\n//       //     [ '+', [ 10, nil ], [ 11, 't' ] ] ] ]\n//\n// The five hunks shown are comprised of individual changes; if there is a\n// related set of changes, they are still shown individually.\n//\n// This callback can also be used with Diff::LCS//sdiff, which will produce\n// results like:\n//\n//     diffs = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextCallbacks)\n//       // This example shows a simplified array format.\n//       // [ [ [ \"-\", [  0, \"a\" ], [  0, nil ] ] ],  // 1\n//       //   [ [ \"+\", [  3, nil ], [  2, \"d\" ] ] ],  // 2\n//       //   [ [ \"!\", [  4, \"h\" ], [  4, \"f\" ] ] ],  // 3\n//       //   [ [ \"+\", [  6, nil ], [  6, \"k\" ] ] ],  // 4\n//       //   [ [ \"!\", [  8, \"n\" ], [  9, \"r\" ] ],    // 5\n//       //     [ \"!\", [  9, \"p\" ], [ 10, \"s\" ] ],\n//       //     [ \"+\", [ 10, nil ], [ 11, \"t\" ] ] ] ]\n//\n// The five hunks are still present, but are significantly shorter in total\n// presentation, because changed items are shown as changes (\"!\") instead of\n// potentially \"mismatched\" pairs of additions and deletions.\n//\n// The result of this operation is similar to that of\n// Diff::LCS::SDiffCallbacks. They may be compared as:\n//\n//     s = Diff::LCS.sdiff(seq1, seq2).reject { |e| e.action == \"=\" }\n//     c = Diff::LCS.sdiff(seq1, seq2, Diff::LCS::ContextDiffCallbacks).flatten\n//\n//     s == c // -> true\n//\n// === Use\n// This callback object must be initialised and can be used by the\n// Diff::LCS//diff or Diff::LCS//sdiff methods.\n//\n//     cbo = Diff::LCS::ContextDiffCallbacks.new\n//     Diff::LCS.LCS(seq1, seq2, cbo)\n//     cbo.finish\n//\n// Note that the call to //finish is absolutely necessary, or the last set of\n// changes will not be visible. Alternatively, can be used as:\n//\n//     cbo = Diff::LCS::ContextDiffCallbacks.new { |tcbo| Diff::LCS.LCS(seq1, seq2, tcbo) }\n//\n// The necessary //finish call will be made.\n//\n// === Simplified Array Format\n// The simplified array format used in the example above can be obtained\n// with:\n//\n//     require 'pp'\n//     pp diffs.map { |e| e.map { |f| f.to_a } }\nContextDiffCallbacks = exports.ContextDiffCallbacks = function(block) {\n  this.hunk = [];\n  this.diffs = [];\n  \n  if(block != null)  {\n    block(this);\n    this.finish();\n  }\n}\n\nContextDiffCallbacks.prototype.finish = function() {\n  add_nonempty_hunk(this);\n}\n\nContextDiffCallbacks.prototype.discard_a = function(event) {\n  this.hunk.push(ContextChange.simplify(event));\n}\n\nContextDiffCallbacks.prototype.discard_b = function(event) {\n  this.hunk.push(ContextChange.simplify(event));\n}\n\nContextDiffCallbacks.prototype.match = function(event) {\n  this.hunk.push(ContextChange.simplify(event));\n}\n\n\n\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}