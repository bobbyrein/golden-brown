{"ast":null,"code":"var util = require('util'),\n  fs = require('fs');\nvar FileIndex = exports.FileIndex = function (repo_path, callback) {\n  var _repo_path = repo_path;\n  var _index_file = repo_path + \"/file-index\";\n  var self = this;\n  // Set up internal index info\n  var _sha_count = 0,\n    _commit_index = {},\n    _commit_order = {},\n    _all_files = {};\n\n  // Set up properites for instance\n  Object.defineProperty(this, \"repo_path\", {\n    get: function () {\n      return _repo_path;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"index_file\", {\n    get: function () {\n      return _index_file;\n    },\n    enumerable: true\n  });\n  // Other values that allow setting\n  Object.defineProperty(this, \"sha_count\", {\n    get: function () {\n      return _sha_count;\n    },\n    set: function (value) {\n      _sha_count = value;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"commit_index\", {\n    get: function () {\n      return _commit_index;\n    },\n    set: function (value) {\n      _commit_index = value;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"commit_order\", {\n    get: function () {\n      return _commit_order;\n    },\n    set: function (value) {\n      _commit_order = value;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"all_files\", {\n    get: function () {\n      return _all_files;\n    },\n    set: function (value) {\n      _all_files = value;\n    },\n    enumerable: true\n  });\n  fs.stat(_index_file, function (err, stat) {\n    if (err) return callback(err, stat);\n    if (stat.isFile() && stat.size < FileIndex.max_file_size) {\n      read_index(self, _index_file, function (err, _index) {\n        if (err) return callback(err, _index);\n        callback(null, _index);\n      });\n    } else {\n      callback(\"index file not found\", null);\n    }\n  });\n};\n\n// Max size for file index\nFileIndex.max_file_size = 10000000;\n\n// Chomp text removing end carriage returns\nvar chomp = function chomp(raw_text) {\n  return raw_text.replace(/(\\n|\\r)+$/, '');\n};\nvar dirname = function (file_name) {\n  var elements = file_name.split('/');\n  elements.pop();\n  if (elements.length == 0) return \".\";\n  return elements.join(\"/\");\n};\n\n// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO\n// TODO Needs to be async reading files in pieces and parsing them\n// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO\n// Read and parse the file index for git\nvar read_index = function (file_index, _index_file, callback) {\n  var current_sha = null;\n  fs.readFile(_index_file, 'ascii', function (err, data) {\n    if (err) return callback(err, data);\n    // Split the text into lines\n    var lines = data.split(\"\\n\");\n    // Iterate over all the lines\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i];\n\n      // Ensure it's a line with a starting sha\n      if (line.match(/^(\\w{40})/)) {\n        // Unpack all the sha values (first one being the current_sha and the rest the parents)\n        var shas = line.match(/(\\w{40})/g);\n        current_sha = shas.shift();\n        // The rest of the sha's are the parents\n        file_index.commit_index[current_sha] = {\n          files: [],\n          parents: shas\n        };\n        file_index.commit_order[current_sha] = file_index.sha_count;\n        file_index.sha_count = file_index.sha_count + 1;\n      } else {\n        var file_name = chomp(line);\n        var tree = '';\n        // Retrieve the directory name for the file passed in\n        var dir = dirname(file_name);\n        // Ensure it's not an empty line        \n        if (line.length > 0) {\n          // Split up the directory\n          var dir_parts = dir.split(\"/\");\n          for (var j = 0; j < dir_parts.length; j++) {\n            var part = dir_parts[j];\n            if (dir_parts[j] != '.') {\n              tree = tree + part + '/';\n              if (file_index.all_files[tree] == null) file_index.all_files[tree] = [];\n              if (file_index.all_files[tree].indexOf(current_sha) == -1) file_index.all_files[tree].unshift(current_sha);\n            }\n          }\n\n          // Finish up\n          if (!file_index.all_files[file_name]) file_index.all_files[file_name] = [];\n          file_index.all_files[file_name].unshift(current_sha);\n          file_index.commit_index[current_sha].files.push(file_name);\n        }\n      }\n    }\n    // Return the parsed index\n    callback(null, file_index);\n  });\n};\n\n// Builds a list of all commits reachable from a single commit\nFileIndex.prototype.commits_from = function (commit_sha, callback) {\n  if (Array.isArray(commit_sha)) return callback(\"unsuported reference\", null);\n  // Define some holding structures\n  var already = {};\n  var final = [];\n  var left_to_do = [commit_sha];\n  var self = this;\n  while (left_to_do.length > 0) {\n    commit_sha = left_to_do.shift();\n    if (!already[commit_sha]) {\n      // Add commit to list of final commits\n      final.push(commit_sha);\n      already[commit_sha] = true;\n\n      // Get parents of the commit and add them to the list\n      var commit = self.commit_index[commit_sha];\n      if (commit) {\n        commit.parents.forEach(function (sha) {\n          left_to_do.push(sha);\n        });\n      }\n    }\n  }\n  // Sort the commits\n  final = this.sort_commits(final);\n  // Callback\n  callback(null, final);\n};\nFileIndex.prototype.sort_commits = function (sha_array) {\n  var self = this;\n  return sha_array.sort(function (a, b) {\n    return compare(parseInt(self.commit_order[b]), parseInt(self.commit_order[a]));\n  });\n};\nvar convert = function (d) {\n  return d.constructor === Date ? d : d.constructor === Array ? new Date(d[0], d[1], d[2]) : d.constructor === Number ? new Date(d) : d.constructor === String ? new Date(d) : typeof d === \"object\" ? new Date(d.year, d.month, d.date) : NaN;\n};\nvar compare = function (a, b) {\n  return isFinite(a = convert(a).valueOf()) && isFinite(b = convert(b).valueOf()) ? (a > b) - (a < b) : NaN;\n};\n\n// Returns files changed at commit sha\nFileIndex.prototype.files = function (commit_sha, callback) {\n  if (!this.commit_index[commit_sha]) return callback(\"no files found for sha: \" + commit_sha, null);\n  callback(null, this.commit_index[commit_sha].files);\n};\n\n// Returns count of all commits\nFileIndex.prototype.count_all = function (callback) {\n  callback(null, this.sha_count);\n};\n\n// returns count of all commits reachable from SHA\nFileIndex.prototype.count = function (commit_sha, callback) {\n  this.commits_from(commit_sha, function (err, commits) {\n    if (err) return callback(err, commits);\n    callback(null, commits.length);\n  });\n};\n\n// returns all commits for a provided file\nFileIndex.prototype.commits_for = function (file, callback) {\n  if (!this.all_files[file]) return callback(\"could not locate any commits for file: \" + file, null);\n  callback(null, this.all_files[file]);\n};\n\n// returns the shas of the last commits for all\n// the files in [] from commit_sha\n// files_matcher can be a regexp or an array\nFileIndex.prototype.last_commits = function (commit_sha, files_matcher, callback) {\n  var self = this;\n  this.commits_from(commit_sha, function (err, acceptable) {\n    if (err) return callback(err, acceptable);\n    var matches = {};\n    if (files_matcher.constructor == RegExp) {\n      // Filter all the files by the matching regular expression\n      files_matcher = Object.keys(self.all_files).filter(function (file) {\n        return file.match(files_matcher);\n      });\n    }\n    if (Array.isArray(files_matcher)) {\n      // Locate the last commit for each file in the files_matcher array\n      for (var files_matcher_index = 0; files_matcher_index < files_matcher.length; files_matcher_index++) {\n        var files = self.all_files[files_matcher[files_matcher_index]];\n        for (var files_index = 0; files_index < files.length; files_index++) {\n          // If the file is included in the list of commits_from then add it to the matches\n          if (acceptable.indexOf(files[files_index]) != -1) {\n            matches[files_matcher[files_matcher_index]] = files[files_index];\n            break;\n          }\n        }\n      }\n    }\n\n    // Return matches\n    callback(null, matches);\n  });\n};","map":{"version":3,"names":["util","require","fs","FileIndex","exports","repo_path","callback","_repo_path","_index_file","self","_sha_count","_commit_index","_commit_order","_all_files","Object","defineProperty","get","enumerable","set","value","stat","err","isFile","size","max_file_size","read_index","_index","chomp","raw_text","replace","dirname","file_name","elements","split","pop","length","join","file_index","current_sha","readFile","data","lines","i","line","match","shas","shift","commit_index","files","parents","commit_order","sha_count","tree","dir","dir_parts","j","part","all_files","indexOf","unshift","push","prototype","commits_from","commit_sha","Array","isArray","already","final","left_to_do","commit","forEach","sha","sort_commits","sha_array","sort","a","b","compare","parseInt","convert","d","constructor","Date","Number","String","year","month","date","NaN","isFinite","valueOf","count_all","count","commits","commits_for","file","last_commits","files_matcher","acceptable","matches","RegExp","keys","filter","files_matcher_index","files_index"],"sources":["/Users/bobbyrein/react-course/golden-brown/node_modules/git/lib/git/file_index.js"],"sourcesContent":["var util = require('util'),\n  fs = require('fs');\n\nvar FileIndex = exports.FileIndex = function(repo_path, callback) {\n  var _repo_path = repo_path;\n  var _index_file = repo_path + \"/file-index\";\n  var self = this;  \n  // Set up internal index info\n  var _sha_count = 0, _commit_index = {}, _commit_order = {}, _all_files = {};\n  \n  // Set up properites for instance\n  Object.defineProperty(this, \"repo_path\", { get: function() { return _repo_path; }, enumerable: true});      \n  Object.defineProperty(this, \"index_file\", { get: function() { return _index_file; }, enumerable: true});        \n  // Other values that allow setting\n  Object.defineProperty(this, \"sha_count\", { get: function() { return _sha_count; }, set: function(value) { _sha_count = value; }, enumerable: true});        \n  Object.defineProperty(this, \"commit_index\", { get: function() { return _commit_index; }, set: function(value) { _commit_index = value; }, enumerable: true});        \n  Object.defineProperty(this, \"commit_order\", { get: function() { return _commit_order; }, set: function(value) { _commit_order = value; }, enumerable: true});        \n  Object.defineProperty(this, \"all_files\", { get: function() { return _all_files; }, set: function(value) { _all_files = value; }, enumerable: true});        \n  \n  fs.stat(_index_file, function(err, stat) {\n    if(err) return callback(err, stat);\n    \n    if(stat.isFile() && stat.size < FileIndex.max_file_size) {\n      read_index(self, _index_file, function(err, _index) {\n        if(err) return callback(err, _index);\n        callback(null, _index);\n      })\n    } else {\n      callback(\"index file not found\", null);\n    }\n  });\n}\n\n// Max size for file index\nFileIndex.max_file_size = 10000000;\n\n// Chomp text removing end carriage returns\nvar chomp = function chomp(raw_text) {\n  return raw_text.replace(/(\\n|\\r)+$/, '');\n}\n\nvar dirname = function(file_name) {\n  var elements = file_name.split('/');\n  elements.pop();  \n  if(elements.length == 0) return \".\";\n  return elements.join(\"/\");\n}\n\n// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO\n// TODO Needs to be async reading files in pieces and parsing them\n// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO\n// Read and parse the file index for git\nvar read_index = function(file_index, _index_file, callback) {\n  var current_sha = null;\n\n  fs.readFile(_index_file, 'ascii', function(err, data) {\n    if(err) return callback(err, data);\n    // Split the text into lines\n    var lines = data.split(\"\\n\");\n    // Iterate over all the lines\n    for(var i = 0; i < lines.length; i++) {\n      var line = lines[i];  \n      \n      // Ensure it's a line with a starting sha\n      if(line.match(/^(\\w{40})/)) {\n        // Unpack all the sha values (first one being the current_sha and the rest the parents)\n        var shas = line.match(/(\\w{40})/g);\n        current_sha = shas.shift();    \n        // The rest of the sha's are the parents\n        file_index.commit_index[current_sha] = {files:[], parents:shas}\n        file_index.commit_order[current_sha] = file_index.sha_count;\n        file_index.sha_count = file_index.sha_count + 1;\n      } else {\n        var file_name = chomp(line);\n        var tree = '';\n        // Retrieve the directory name for the file passed in\n        var dir = dirname(file_name);\n        // Ensure it's not an empty line        \n        if(line.length > 0) {\n          // Split up the directory\n          var dir_parts = dir.split(\"/\");\n          for(var j = 0; j < dir_parts.length; j++) {\n            var part = dir_parts[j];\n            \n            if(dir_parts[j] != '.') {\n              tree = tree + part + '/'\n              if(file_index.all_files[tree] == null) file_index.all_files[tree]  = [];\n              if(file_index.all_files[tree].indexOf(current_sha) == -1)\n                file_index.all_files[tree].unshift(current_sha);\n            }\n          }\n          \n          // Finish up\n          if(!file_index.all_files[file_name]) file_index.all_files[file_name] = [];\n          file_index.all_files[file_name].unshift(current_sha);\n          file_index.commit_index[current_sha].files.push(file_name);\n        }                \n      }\n    }    \n    // Return the parsed index\n    callback(null, file_index);\n  });  \n}\n\n// Builds a list of all commits reachable from a single commit\nFileIndex.prototype.commits_from = function(commit_sha, callback) {\n  if(Array.isArray(commit_sha)) return callback(\"unsuported reference\", null);\n  // Define some holding structures\n  var already = {};\n  var final = [];\n  var left_to_do = [commit_sha];\n  var self = this;\n  \n  while(left_to_do.length > 0) {\n    commit_sha = left_to_do.shift();\n        \n    if(!already[commit_sha]) {\n      // Add commit to list of final commits\n      final.push(commit_sha);\n      already[commit_sha] = true;\n            \n      // Get parents of the commit and add them to the list\n      var commit = self.commit_index[commit_sha];\n      if(commit) {\n        commit.parents.forEach(function(sha) {\n          left_to_do.push(sha);\n        });        \n      }\n    }\n  }  \n  // Sort the commits\n  final = this.sort_commits(final);\n  // Callback\n  callback(null, final);\n}\n\nFileIndex.prototype.sort_commits = function(sha_array) {\n  var self = this;\n  \n  return sha_array.sort(function(a, b) {\n    return compare(parseInt(self.commit_order[b]), parseInt(self.commit_order[a]));\n  })\n}\n\nvar convert = function(d) {\n  return (\n    d.constructor === Date ? d :\n    d.constructor === Array ? new Date(d[0],d[1],d[2]) :\n    d.constructor === Number ? new Date(d) :\n    d.constructor === String ? new Date(d) :\n    typeof d === \"object\" ? new Date(d.year,d.month,d.date) :\n    NaN\n  );\n}\n\nvar compare = function(a,b) {\n  return (\n    isFinite(a=convert(a).valueOf()) &&\n    isFinite(b=convert(b).valueOf()) ?\n    (a>b)-(a<b) :\n    NaN\n  );\n}\n\n// Returns files changed at commit sha\nFileIndex.prototype.files = function(commit_sha, callback) {\n  if(!this.commit_index[commit_sha]) return callback(\"no files found for sha: \" + commit_sha, null);  \n  callback(null, this.commit_index[commit_sha].files);\n}\n\n// Returns count of all commits\nFileIndex.prototype.count_all = function(callback) {\n  callback(null, this.sha_count);\n}\n\n// returns count of all commits reachable from SHA\nFileIndex.prototype.count = function(commit_sha, callback) {\n  this.commits_from(commit_sha, function(err, commits) {\n    if(err) return callback(err, commits);\n    callback(null, commits.length);\n  })\n}\n\n// returns all commits for a provided file\nFileIndex.prototype.commits_for = function(file, callback) {\n  if(!this.all_files[file]) return callback(\"could not locate any commits for file: \" + file, null);\n  callback(null, this.all_files[file])\n}\n\n// returns the shas of the last commits for all\n// the files in [] from commit_sha\n// files_matcher can be a regexp or an array\nFileIndex.prototype.last_commits = function(commit_sha, files_matcher, callback) {\n  var self = this;\n  \n  this.commits_from(commit_sha, function(err, acceptable) {\n    if(err) return callback(err, acceptable);    \n    var matches = {};\n    \n    if(files_matcher.constructor == RegExp) {\n      // Filter all the files by the matching regular expression\n      files_matcher = Object.keys(self.all_files).filter(function(file) {        \n        return file.match(files_matcher);\n      });\n    }\n    \n    if(Array.isArray(files_matcher)) {\n      // Locate the last commit for each file in the files_matcher array\n      for(var files_matcher_index = 0; files_matcher_index < files_matcher.length; files_matcher_index++) {\n        var files = self.all_files[files_matcher[files_matcher_index]];\n        \n        for(var files_index = 0; files_index < files.length; files_index++) {\n          // If the file is included in the list of commits_from then add it to the matches\n          if(acceptable.indexOf(files[files_index]) != -1) {\n            matches[files_matcher[files_matcher_index]] = files[files_index];\n            break;\n          }          \n        }\n      }\n    }\n    \n    // Return matches\n    callback(null, matches);\n  });\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}